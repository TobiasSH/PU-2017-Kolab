(function(f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f()
    } else if (typeof define === "function" && define.amd) {
        define([], f)
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window
        } else if (typeof global !== "undefined") {
            g = global
        } else if (typeof self !== "undefined") {
            g = self
        } else {
            g = this
        }
        g.Room = f()
    }
})(function() {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, l, l.exports, e, t, n, r)
            }
            return n[o].exports
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s
    })({
        1: [function(require, module, exports) {
            // shim for using process in browser

            var process = module.exports = {};
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }

            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = setTimeout(cleanUpNextTick);
                draining = true;

                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                clearTimeout(timeout);
            }

            process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    setTimeout(drainQueue, 0);
                }
            };

            // v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            };
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = ''; // empty string to avoid regexp issues
            process.versions = {};

            function noop() {}

            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;

            process.binding = function(name) {
                throw new Error('process.binding is not supported');
            };

            process.cwd = function() {
                return '/'
            };
            process.chdir = function(dir) {
                throw new Error('process.chdir is not supported');
            };
            process.umask = function() {
                return 0;
            };

        }, {}],
        2: [function(require, module, exports) {
            (function(process) {
                'use strict';
                var escapeStringRegexp = require('escape-string-regexp');
                var ansiStyles = require('ansi-styles');
                var stripAnsi = require('strip-ansi');
                var hasAnsi = require('has-ansi');
                var supportsColor = require('supports-color');
                var defineProps = Object.defineProperties;
                var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

                function Chalk(options) {
                    // detect mode if not set manually
                    this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
                }

                // use bright blue on Windows as the normal blue color is illegible
                if (isSimpleWindowsTerm) {
                    ansiStyles.blue.open = '\u001b[94m';
                }

                var styles = (function() {
                    var ret = {};

                    Object.keys(ansiStyles).forEach(function(key) {
                        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

                        ret[key] = {
                            get: function() {
                                return build.call(this, this._styles.concat(key));
                            }
                        };
                    });

                    return ret;
                })();

                var proto = defineProps(function chalk() {}, styles);

                function build(_styles) {
                    var builder = function() {
                        return applyStyle.apply(builder, arguments);
                    };

                    builder._styles = _styles;
                    builder.enabled = this.enabled;
                    // __proto__ is used because we must return a function, but there is
                    // no way to create a function with a different prototype.
                    /* eslint-disable no-proto */
                    builder.__proto__ = proto;

                    return builder;
                }

                function applyStyle() {
                    // support varags, but simply cast to string in case there's only one arg
                    var args = arguments;
                    var argsLen = args.length;
                    var str = argsLen !== 0 && String(arguments[0]);

                    if (argsLen > 1) {
                        // don't slice `arguments`, it prevents v8 optimizations
                        for (var a = 1; a < argsLen; a++) {
                            str += ' ' + args[a];
                        }
                    }

                    if (!this.enabled || !str) {
                        return str;
                    }

                    var nestedStyles = this._styles;
                    var i = nestedStyles.length;

                    // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
                    // see https://github.com/chalk/chalk/issues/58
                    // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
                    var originalDim = ansiStyles.dim.open;
                    if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
                        ansiStyles.dim.open = '';
                    }

                    while (i--) {
                        var code = ansiStyles[nestedStyles[i]];

                        // Replace any instances already present with a re-opening code
                        // otherwise only the part of the string until said closing code
                        // will be colored, and the rest will simply be 'plain'.
                        str = code.open + str.replace(code.closeRe, code.open) + code.close;
                    }

                    // Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
                    ansiStyles.dim.open = originalDim;

                    return str;
                }

                function init() {
                    var ret = {};

                    Object.keys(styles).forEach(function(name) {
                        ret[name] = {
                            get: function() {
                                return build.call(this, [name]);
                            }
                        };
                    });

                    return ret;
                }

                defineProps(Chalk.prototype, init());

                module.exports = new Chalk();
                module.exports.styles = ansiStyles;
                module.exports.hasColor = hasAnsi;
                module.exports.stripColor = stripAnsi;
                module.exports.supportsColor = supportsColor;

            }).call(this, require('_process'))

        }, {
            "_process": 1,
            "ansi-styles": 3,
            "escape-string-regexp": 4,
            "has-ansi": 5,
            "strip-ansi": 7,
            "supports-color": 9
        }],
        3: [function(require, module, exports) {
            'use strict';

            function assembleStyles() {
                var styles = {
                    modifiers: {
                        reset: [0, 0],
                        bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
                        dim: [2, 22],
                        italic: [3, 23],
                        underline: [4, 24],
                        inverse: [7, 27],
                        hidden: [8, 28],
                        strikethrough: [9, 29]
                    },
                    colors: {
                        black: [30, 39],
                        red: [31, 39],
                        green: [32, 39],
                        yellow: [33, 39],
                        blue: [34, 39],
                        magenta: [35, 39],
                        cyan: [36, 39],
                        white: [37, 39],
                        gray: [90, 39]
                    },
                    bgColors: {
                        bgBlack: [40, 49],
                        bgRed: [41, 49],
                        bgGreen: [42, 49],
                        bgYellow: [43, 49],
                        bgBlue: [44, 49],
                        bgMagenta: [45, 49],
                        bgCyan: [46, 49],
                        bgWhite: [47, 49]
                    }
                };

                // fix humans
                styles.colors.grey = styles.colors.gray;

                Object.keys(styles).forEach(function(groupName) {
                    var group = styles[groupName];

                    Object.keys(group).forEach(function(styleName) {
                        var style = group[styleName];

                        styles[styleName] = group[styleName] = {
                            open: '\u001b[' + style[0] + 'm',
                            close: '\u001b[' + style[1] + 'm'
                        };
                    });

                    Object.defineProperty(styles, groupName, {
                        value: group,
                        enumerable: false
                    });
                });

                return styles;
            }

            Object.defineProperty(module, 'exports', {
                enumerable: true,
                get: assembleStyles
            });

        }, {}],
        4: [function(require, module, exports) {
            'use strict';

            var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

            module.exports = function(str) {
                if (typeof str !== 'string') {
                    throw new TypeError('Expected a string');
                }

                return str.replace(matchOperatorsRe, '\\$&');
            };

        }, {}],
        5: [function(require, module, exports) {
            'use strict';
            var ansiRegex = require('ansi-regex');
            var re = new RegExp(ansiRegex().source); // remove the `g` flag
            module.exports = re.test.bind(re);

        }, {
            "ansi-regex": 6
        }],
        6: [function(require, module, exports) {
            'use strict';
            module.exports = function() {
                return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
            };

        }, {}],
        7: [function(require, module, exports) {
            'use strict';
            var ansiRegex = require('ansi-regex')();

            module.exports = function(str) {
                return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
            };

        }, {
            "ansi-regex": 8
        }],
        8: [function(require, module, exports) {
            arguments[4][6][0].apply(exports, arguments)
        }, {
            "dup": 6
        }],
        9: [function(require, module, exports) {
            (function(process) {
                'use strict';
                var argv = process.argv;

                var terminator = argv.indexOf('--');
                var hasFlag = function(flag) {
                    flag = '--' + flag;
                    var pos = argv.indexOf(flag);
                    return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
                };

                module.exports = (function() {
                    if ('FORCE_COLOR' in process.env) {
                        return true;
                    }

                    if (hasFlag('no-color') ||
                        hasFlag('no-colors') ||
                        hasFlag('color=false')) {
                        return false;
                    }

                    if (hasFlag('color') ||
                        hasFlag('colors') ||
                        hasFlag('color=true') ||
                        hasFlag('color=always')) {
                        return true;
                    }

                    if (process.stdout && !process.stdout.isTTY) {
                        return false;
                    }

                    if (process.platform === 'win32') {
                        return true;
                    }

                    if ('COLORTERM' in process.env) {
                        return true;
                    }

                    if (process.env.TERM === 'dumb') {
                        return false;
                    }

                    if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
                        return true;
                    }

                    return false;
                })();

            }).call(this, require('_process'))

        }, {
            "_process": 1
        }],
        10: [function(require, module, exports) {
            /*!
             * mustache.js - Logic-less {{mustache}} templates with JavaScript
             * http://github.com/janl/mustache.js
             */

            /*global define: false Mustache: true*/

            (function defineMustache(global, factory) {
                if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
                    factory(exports); // CommonJS
                } else if (typeof define === 'function' && define.amd) {
                    define(['exports'], factory); // AMD
                } else {
                    global.Mustache = {};
                    factory(Mustache); // script, wsh, asp
                }
            }(this, function mustacheFactory(mustache) {

                var objectToString = Object.prototype.toString;
                var isArray = Array.isArray || function isArrayPolyfill(object) {
                    return objectToString.call(object) === '[object Array]';
                };

                function isFunction(object) {
                    return typeof object === 'function';
                }

                /**
                 * More correct typeof string handling array
                 * which normally returns typeof 'object'
                 */
                function typeStr(obj) {
                    return isArray(obj) ? 'array' : typeof obj;
                }

                function escapeRegExp(string) {
                    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
                }

                /**
                 * Null safe way of checking whether or not an object,
                 * including its prototype, has a given property
                 */
                function hasProperty(obj, propName) {
                    return obj != null && typeof obj === 'object' && (propName in obj);
                }

                // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
                // See https://github.com/janl/mustache.js/issues/189
                var regExpTest = RegExp.prototype.test;

                function testRegExp(re, string) {
                    return regExpTest.call(re, string);
                }

                var nonSpaceRe = /\S/;

                function isWhitespace(string) {
                    return !testRegExp(nonSpaceRe, string);
                }

                var entityMap = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    '/': '&#x2F;'
                };

                function escapeHtml(string) {
                    return String(string).replace(/[&<>"'\/]/g, function fromEntityMap(s) {
                        return entityMap[s];
                    });
                }

                var whiteRe = /\s*/;
                var spaceRe = /\s+/;
                var equalsRe = /\s*=/;
                var curlyRe = /\s*\}/;
                var tagRe = /#|\^|\/|>|\{|&|=|!/;

                /**
                 * Breaks up the given `template` string into a tree of tokens. If the `tags`
                 * argument is given here it must be an array with two string values: the
                 * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
                 * course, the default is to use mustaches (i.e. mustache.tags).
                 *
                 * A token is an array with at least 4 elements. The first element is the
                 * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
                 * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
                 * all text that appears outside a symbol this element is "text".
                 *
                 * The second element of a token is its "value". For mustache tags this is
                 * whatever else was inside the tag besides the opening symbol. For text tokens
                 * this is the text itself.
                 *
                 * The third and fourth elements of the token are the start and end indices,
                 * respectively, of the token in the original template.
                 *
                 * Tokens that are the root node of a subtree contain two more elements: 1) an
                 * array of tokens in the subtree and 2) the index in the original template at
                 * which the closing tag for that section begins.
                 */
                function parseTemplate(template, tags) {
                    if (!template)
                        return [];

                    var sections = []; // Stack to hold section tokens
                    var tokens = []; // Buffer to hold the tokens
                    var spaces = []; // Indices of whitespace tokens on the current line
                    var hasTag = false; // Is there a {{tag}} on the current line?
                    var nonSpace = false; // Is there a non-space char on the current line?

                    // Strips all whitespace tokens array for the current line
                    // if there was a {{#tag}} on it and otherwise only space.
                    function stripSpace() {
                        if (hasTag && !nonSpace) {
                            while (spaces.length)
                                delete tokens[spaces.pop()];
                        } else {
                            spaces = [];
                        }

                        hasTag = false;
                        nonSpace = false;
                    }

                    var openingTagRe, closingTagRe, closingCurlyRe;

                    function compileTags(tagsToCompile) {
                        if (typeof tagsToCompile === 'string')
                            tagsToCompile = tagsToCompile.split(spaceRe, 2);

                        if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
                            throw new Error('Invalid tags: ' + tagsToCompile);

                        openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
                        closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
                        closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
                    }

                    compileTags(tags || mustache.tags);

                    var scanner = new Scanner(template);

                    var start, type, value, chr, token, openSection;
                    while (!scanner.eos()) {
                        start = scanner.pos;

                        // Match any text between tags.
                        value = scanner.scanUntil(openingTagRe);

                        if (value) {
                            for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
                                chr = value.charAt(i);

                                if (isWhitespace(chr)) {
                                    spaces.push(tokens.length);
                                } else {
                                    nonSpace = true;
                                }

                                tokens.push(['text', chr, start, start + 1]);
                                start += 1;

                                // Check for whitespace on the current line.
                                if (chr === '\n')
                                    stripSpace();
                            }
                        }

                        // Match the opening tag.
                        if (!scanner.scan(openingTagRe))
                            break;

                        hasTag = true;

                        // Get the tag type.
                        type = scanner.scan(tagRe) || 'name';
                        scanner.scan(whiteRe);

                        // Get the tag value.
                        if (type === '=') {
                            value = scanner.scanUntil(equalsRe);
                            scanner.scan(equalsRe);
                            scanner.scanUntil(closingTagRe);
                        } else if (type === '{') {
                            value = scanner.scanUntil(closingCurlyRe);
                            scanner.scan(curlyRe);
                            scanner.scanUntil(closingTagRe);
                            type = '&';
                        } else {
                            value = scanner.scanUntil(closingTagRe);
                        }

                        // Match the closing tag.
                        if (!scanner.scan(closingTagRe))
                            throw new Error('Unclosed tag at ' + scanner.pos);

                        token = [type, value, start, scanner.pos];
                        tokens.push(token);

                        if (type === '#' || type === '^') {
                            sections.push(token);
                        } else if (type === '/') {
                            // Check section nesting.
                            openSection = sections.pop();

                            if (!openSection)
                                throw new Error('Unopened section "' + value + '" at ' + start);

                            if (openSection[1] !== value)
                                throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
                        } else if (type === 'name' || type === '{' || type === '&') {
                            nonSpace = true;
                        } else if (type === '=') {
                            // Set the tags for the next time around.
                            compileTags(value);
                        }
                    }

                    // Make sure there are no open sections when we're done.
                    openSection = sections.pop();

                    if (openSection)
                        throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

                    return nestTokens(squashTokens(tokens));
                }

                /**
                 * Combines the values of consecutive text tokens in the given `tokens` array
                 * to a single token.
                 */
                function squashTokens(tokens) {
                    var squashedTokens = [];

                    var token, lastToken;
                    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
                        token = tokens[i];

                        if (token) {
                            if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
                                lastToken[1] += token[1];
                                lastToken[3] = token[3];
                            } else {
                                squashedTokens.push(token);
                                lastToken = token;
                            }
                        }
                    }

                    return squashedTokens;
                }

                /**
                 * Forms the given array of `tokens` into a nested tree structure where
                 * tokens that represent a section have two additional items: 1) an array of
                 * all tokens that appear in that section and 2) the index in the original
                 * template that represents the end of that section.
                 */
                function nestTokens(tokens) {
                    var nestedTokens = [];
                    var collector = nestedTokens;
                    var sections = [];

                    var token, section;
                    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
                        token = tokens[i];

                        switch (token[0]) {
                            case '#':
                            case '^':
                                collector.push(token);
                                sections.push(token);
                                collector = token[4] = [];
                                break;
                            case '/':
                                section = sections.pop();
                                section[5] = token[2];
                                collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
                                break;
                            default:
                                collector.push(token);
                        }
                    }

                    return nestedTokens;
                }

                /**
                 * A simple string scanner that is used by the template parser to find
                 * tokens in template strings.
                 */
                function Scanner(string) {
                    this.string = string;
                    this.tail = string;
                    this.pos = 0;
                }

                /**
                 * Returns `true` if the tail is empty (end of string).
                 */
                Scanner.prototype.eos = function eos() {
                    return this.tail === '';
                };

                /**
                 * Tries to match the given regular expression at the current position.
                 * Returns the matched text if it can match, the empty string otherwise.
                 */
                Scanner.prototype.scan = function scan(re) {
                    var match = this.tail.match(re);

                    if (!match || match.index !== 0)
                        return '';

                    var string = match[0];

                    this.tail = this.tail.substring(string.length);
                    this.pos += string.length;

                    return string;
                };

                /**
                 * Skips all text until the given regular expression can be matched. Returns
                 * the skipped string, which is the entire tail if no match can be made.
                 */
                Scanner.prototype.scanUntil = function scanUntil(re) {
                    var index = this.tail.search(re),
                        match;

                    switch (index) {
                        case -1:
                            match = this.tail;
                            this.tail = '';
                            break;
                        case 0:
                            match = '';
                            break;
                        default:
                            match = this.tail.substring(0, index);
                            this.tail = this.tail.substring(index);
                    }

                    this.pos += match.length;

                    return match;
                };

                /**
                 * Represents a rendering context by wrapping a view object and
                 * maintaining a reference to the parent context.
                 */
                function Context(view, parentContext) {
                    this.view = view;
                    this.cache = {
                        '.': this.view
                    };
                    this.parent = parentContext;
                }

                /**
                 * Creates a new context using the given view with this context
                 * as the parent.
                 */
                Context.prototype.push = function push(view) {
                    return new Context(view, this);
                };

                /**
                 * Returns the value of the given name in this context, traversing
                 * up the context hierarchy if the value is absent in this context's view.
                 */
                Context.prototype.lookup = function lookup(name) {
                    var cache = this.cache;

                    var value;
                    if (cache.hasOwnProperty(name)) {
                        value = cache[name];
                    } else {
                        var context = this,
                            names, index, lookupHit = false;

                        while (context) {
                            if (name.indexOf('.') > 0) {
                                value = context.view;
                                names = name.split('.');
                                index = 0;

                                /**
                                 * Using the dot notion path in `name`, we descend through the
                                 * nested objects.
                                 *
                                 * To be certain that the lookup has been successful, we have to
                                 * check if the last object in the path actually has the property
                                 * we are looking for. We store the result in `lookupHit`.
                                 *
                                 * This is specially necessary for when the value has been set to
                                 * `undefined` and we want to avoid looking up parent contexts.
                                 **/
                                while (value != null && index < names.length) {
                                    if (index === names.length - 1)
                                        lookupHit = hasProperty(value, names[index]);

                                    value = value[names[index++]];
                                }
                            } else {
                                value = context.view[name];
                                lookupHit = hasProperty(context.view, name);
                            }

                            if (lookupHit)
                                break;

                            context = context.parent;
                        }

                        cache[name] = value;
                    }

                    if (isFunction(value))
                        value = value.call(this.view);

                    return value;
                };

                /**
                 * A Writer knows how to take a stream of tokens and render them to a
                 * string, given a context. It also maintains a cache of templates to
                 * avoid the need to parse the same template twice.
                 */
                function Writer() {
                    this.cache = {};
                }

                /**
                 * Clears all cached templates in this writer.
                 */
                Writer.prototype.clearCache = function clearCache() {
                    this.cache = {};
                };

                /**
                 * Parses and caches the given `template` and returns the array of tokens
                 * that is generated from the parse.
                 */
                Writer.prototype.parse = function parse(template, tags) {
                    var cache = this.cache;
                    var tokens = cache[template];

                    if (tokens == null)
                        tokens = cache[template] = parseTemplate(template, tags);

                    return tokens;
                };

                /**
                 * High-level method that is used to render the given `template` with
                 * the given `view`.
                 *
                 * The optional `partials` argument may be an object that contains the
                 * names and templates of partials that are used in the template. It may
                 * also be a function that is used to load partial templates on the fly
                 * that takes a single argument: the name of the partial.
                 */
                Writer.prototype.render = function render(template, view, partials) {
                    var tokens = this.parse(template);
                    var context = (view instanceof Context) ? view : new Context(view);
                    return this.renderTokens(tokens, context, partials, template);
                };

                /**
                 * Low-level method that renders the given array of `tokens` using
                 * the given `context` and `partials`.
                 *
                 * Note: The `originalTemplate` is only ever used to extract the portion
                 * of the original template that was contained in a higher-order section.
                 * If the template doesn't use higher-order sections, this argument may
                 * be omitted.
                 */
                Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {
                    var buffer = '';

                    var token, symbol, value;
                    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
                        value = undefined;
                        token = tokens[i];
                        symbol = token[0];

                        if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
                        else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
                        else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
                        else if (symbol === '&') value = this.unescapedValue(token, context);
                        else if (symbol === 'name') value = this.escapedValue(token, context);
                        else if (symbol === 'text') value = this.rawValue(token);

                        if (value !== undefined)
                            buffer += value;
                    }

                    return buffer;
                };

                Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate) {
                    var self = this;
                    var buffer = '';
                    var value = context.lookup(token[1]);

                    // This function is used to render an arbitrary template
                    // in the current context by higher-order sections.
                    function subRender(template) {
                        return self.render(template, context, partials);
                    }

                    if (!value) return;

                    if (isArray(value)) {
                        for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
                            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
                        }
                    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
                        buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
                    } else if (isFunction(value)) {
                        if (typeof originalTemplate !== 'string')
                            throw new Error('Cannot use higher-order sections without the original template');

                        // Extract the portion of the original template that the section contains.
                        value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

                        if (value != null)
                            buffer += value;
                    } else {
                        buffer += this.renderTokens(token[4], context, partials, originalTemplate);
                    }
                    return buffer;
                };

                Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate) {
                    var value = context.lookup(token[1]);

                    // Use JavaScript's definition of falsy. Include empty arrays.
                    // See https://github.com/janl/mustache.js/issues/186
                    if (!value || (isArray(value) && value.length === 0))
                        return this.renderTokens(token[4], context, partials, originalTemplate);
                };

                Writer.prototype.renderPartial = function renderPartial(token, context, partials) {
                    if (!partials) return;

                    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
                    if (value != null)
                        return this.renderTokens(this.parse(value), context, partials, value);
                };

                Writer.prototype.unescapedValue = function unescapedValue(token, context) {
                    var value = context.lookup(token[1]);
                    if (value != null)
                        return value;
                };

                Writer.prototype.escapedValue = function escapedValue(token, context) {
                    var value = context.lookup(token[1]);
                    if (value != null)
                        return mustache.escape(value);
                };

                Writer.prototype.rawValue = function rawValue(token) {
                    return token[1];
                };

                mustache.name = 'mustache.js';
                mustache.version = '2.1.3';
                mustache.tags = ['{{', '}}'];

                // All high-level mustache.* functions use this writer.
                var defaultWriter = new Writer();

                /**
                 * Clears all cached templates in the default writer.
                 */
                mustache.clearCache = function clearCache() {
                    return defaultWriter.clearCache();
                };

                /**
                 * Parses and caches the given template in the default writer and returns the
                 * array of tokens it contains. Doing this ahead of time avoids the need to
                 * parse templates on the fly as they are rendered.
                 */
                mustache.parse = function parse(template, tags) {
                    return defaultWriter.parse(template, tags);
                };

                /**
                 * Renders the `template` with the given `view` and `partials` using the
                 * default writer.
                 */
                mustache.render = function render(template, view, partials) {
                    if (typeof template !== 'string') {
                        throw new TypeError('Invalid template! Template should be a "string" ' +
                            'but "' + typeStr(template) + '" was given as the first ' +
                            'argument for mustache#render(template, view, partials)');
                    }

                    return defaultWriter.render(template, view, partials);
                };

                // This is here for backwards compatibility with 0.4.x.,
                /*eslint-disable */ // eslint wants camel cased function name
                mustache.to_html = function to_html(template, view, partials, send) {
                    /*eslint-enable*/

                    var result = mustache.render(template, view, partials);

                    if (isFunction(send)) {
                        send(result);
                    } else {
                        return result;
                    }
                };

                // Export the escaping function so that the user may override it.
                // See https://github.com/janl/mustache.js/issues/244
                mustache.escape = escapeHtml;

                // Export these mainly for testing, but also for advanced usage.
                mustache.Scanner = Scanner;
                mustache.Context = Context;
                mustache.Writer = Writer;

            }));

        }, {}],
        11: [function(require, module, exports) {
            var util = require('./util');
            var compiler = require('./compiler');
            var inject = require('./dependency').inject;
            var element = require('./element');
            var appfactory = require('./factory');
            var debug = util.debug('Room.application', 0);

            function RoomApplication(name, deps, opts) {
                this.name = name;
                this.components = {};
                this.services = {};
                this.elements = {};

                if (!Array.isArray(deps) && typeof deps === 'object') {
                    opts = deps;
                    deps = [];
                }

                this.dependencies = deps ||  [];
                this.options = opts ||  {};

                this.router = {
                    url: window.location.pathname,
                    filename: function(url) {
                        return url.substring(url.lastIndexOf('/') + 1);
                    }
                };

                // Resolve dependencies for application module
                this.checkDependencies();
            };

            RoomApplication.prototype.checkDependencies = function() {
                var self = this;
                debug.start('checkDependencies');
                self.dependencies.forEach(function(dep) {
                    if (!window[dep]) {
                        debug.error(
                            'Dependency ' + dep + ' is required for using ' +
                            'module \'' + self.name + '\''
                        );
                        return;
                    }
                });
                debug.info('No dependency found or everything included');
                debug.end();
            };

            RoomApplication.prototype.register = function(name, factory) {
                debug.start('register');
                var self = this;
                var handler, deps, injector = [],
                    required = [],
                    ready = true;
                if (Array.isArray(factory)) {
                    handler = factory.pop();
                    deps = factory;
                } else {
                    handler = factory;
                    deps = [];
                }

                deps.forEach(function(needed) {
                    var searching = inject(self, needed);
                    if (!searching) {
                        ready = false;
                        required.push(needed);
                    } else {
                        injector.push(searching);
                    }
                });

                if (!(self.components[name])) {
                    var internal = {
                        name: name,
                        ready: ready,
                        dependencies: deps,
                        inject: injector,
                        required: required
                    };

                    internal = appfactory.component(internal);
                    self.components[name] = internal;
                    internal.factory = handler.apply(internal, internal.inject);
                }
                debug.end();
            };

            RoomApplication.prototype.initComponent = function(component) {
                debug.start('initComponent:' + component.name);
                if (!component.registered) {
                    component.registered = true;
                    element.register(this, component.name, component.factory.shadow);
                    (component.factory.init || function() {
                        // Default behavior on registration process
                        debug.info('Registering ' + this.name);
                    }).apply(component, component.inject);
                } else {
                    debug.info('Component ' + component.name + ' already registered');
                }
                debug.end
            }

            RoomApplication.prototype.init = function(hook) {
                var self = this;
                for (var index in self.components) {
                    var component = self.components[index];
                    if (!component.ready && component.required.length > 0) {
                        component.required.forEach(function(subindex) {
                            self.initComponent(self.components[subindex]);
                        });
                    }
                    self.initComponent(component);
                }
                compiler.application(self.name);
                (hook || function() {
                    debug.info('Application ready');
                }).apply(self);
            };

            RoomApplication.prototype.find = function(name) {
                return this.components[util.camelize(name)];
            };

            exports.Application = RoomApplication;

            exports.app = function(name, deps, opts) {
                var inst = new RoomApplication(name, deps, opts);
                return inst;
            };

        }, {
            "./compiler": 12,
            "./dependency": 14,
            "./element": 15,
            "./factory": 16,
            "./util": 22
        }],
        12: [function(require, module, exports) {
            var util = require('./util');
            var config = require('./config');
            var engine = require('mustache');
            var debug = util.debug('Room.compiler', 0);

            exports.application = function(name) {
                var attr = config.prefix + '-' + config.attr.app;
                var appnode = util.$('[' + attr + '="' + util.hyphenate(name) + '"]');
                if (appnode === undefined || !appnode) {
                    var body = document.body;
                    util.$.attr(body, '-' + config.attr.app, util.hyphenate(name));
                }
            };

            exports.render = function(target, data) {
                if (!data || !target) {
                    debug.error('No data or node given for rendering');
                    return false;
                }
                target.innerHTML = engine.render(target.innerHTML, data);
            };

        }, {
            "./config": 13,
            "./util": 22,
            "mustache": 10
        }],
        13: [function(require, module, exports) {
            exports = module.exports = {
                debug: true,
                shadow: true,
                prefix: 'rm',
                attr: {
                    component: 'component',
                    app: 'app'
                }
            };

        }, {}],
        14: [function(require, module, exports) {
            var debug = require('./util').debug('Dependency', 0);

            exports.inject = function(app, name) {
                debug.start('inject:' + name);
                var result = app.components[name];
                if (result) {
                    return result;
                }
                app.dependencies.forEach(function(dependency) {
                    debug.info('Looking for global dependency ' + dependency);
                    if (dependency === name) {
                        debug.info('Global dependency found!');
                        result = window[dependency];
                    }
                });
                return result;
                debug.end();
            };

        }, {
            "./util": 22
        }],
        15: [function(require, module, exports) {
            var util = require('./util');
            var debug = util.debug('Element', -1);
            var config = require('./config');

            var registeredByDefault = [
                'header',
                'div',
                'footer',
                'main',
                'p',
                'span',
                'nav',
                'ul',
                'dl',
                'a',
                'i'
            ];

            var isRegisteredElement = function(name) {
                return document.createElement(name).constructor !== HTMLElement;
            };

            exports.isRegistered = isRegisteredElement;

            exports.register = function(app, identifier, hook) {
                debug.start('register');
                if (isRegisteredElement(identifier) || registeredByDefault.indexOf(identifier) > -1) {
                    debug.info('Element ' + identifier + ' already registered in the DOM');
                    return false;
                }
                var proto = Object.create(HTMLElement.prototype);
                proto.createdCallback = function() {
                    var shadow = this.createShadowRoot();
                    (hook ||   function() {}).apply(shadow);
                };
                var anchestor = app.elements[util.camelize(identifier)];
                if (anchestor === undefined || !anchestor) {
                    anchestor = document.registerElement(util.hyphenate(identifier), {
                        prototype: proto
                    });
                }
                debug.end();
            };

        }, {
            "./config": 13,
            "./util": 22
        }],
        16: [function(require, module, exports) {
            var config = require('./config');
            var $$ = require('./util/query').$;
            var compiler = require('./compiler');
            var hyphenate = require('./util/core').hyphenate;
            var camelize = require('./util/core').camelize;
            var listen = {
                on: require('./util/dom').on,
                off: require('./util/dom').off
            };

            exports.component = function(factory) {
                factory.fire = function fire(event, data, hook) {
                    var target = 'on' + event.charAt(0).toUpperCase() + event.slice(1);
                    (hook || function() {})(self.factory[target].apply(self, data));
                };

                factory.get = function getNodes() {
                    var all = [],
                        final = [],
                        target = hyphenate(factory.name);
                    [
                        $$('.' + target),
                        $$('[' + config.prefix + '-' + config.attr.component + '="' + target + '"]'),
                        $$('@' + target)
                    ].forEach(function(node) {
                        if (typeof node !== undefined && node) {
                            all.push(node);
                        }
                    });
                    all.forEach(function(set) {
                        if (set && typeof set !== undefined) {
                            try {
                                [].slice.call(set).forEach(function(child) {
                                    final.push(child);
                                });
                            } catch (ex) {
                                console.error(ex.message);
                            }
                        }
                    });
                    return final;
                };

                factory.bind = function bindEvent(event, hook) {
                    factory.nodes.forEach(function(finding) {
                        if (typeof finding !== undefined && finding !== null) {
                            listen.on(finding, event, hook);
                        }
                    });
                };

                factory.renderData = function renderData(data) {
                    this.viewbag = data;
                    factory.nodes.forEach(function(node) {
                        compiler.render(node, data);
                    });
                };

                factory.unbind = function unbindEvent(event, hook) {
                    factory.nodes.forEach(function(finding) {
                        if (typeof finding !== undefined && finding !== null) {
                            listen.off(finding, event, hook);
                        }
                    });
                };

                factory.nodes = factory.get();

                return factory;
            };

        }, {
            "./compiler": 12,
            "./config": 13,
            "./util/core": 19,
            "./util/dom": 21,
            "./util/query": 23
        }],
        17: [function(require, module, exports) {
            (function(process) {
                var util = require('./util');
                var debug = util.debug('Room', 0)._env('node');

                if (typeof window === 'undefined' && process) {
                    debug.error('Room must run in a browser and not Node.js');
                }

                var room = room || {};
                room.app = require('./app').app;
                room.$ = require('./util/query').$;
                util.mixin(room.$, require('./util/ajax'));
                exports = module.exports = room;

            }).call(this, require('_process'))

        }, {
            "./app": 11,
            "./util": 22,
            "./util/ajax": 18,
            "./util/query": 23,
            "_process": 1
        }],
        18: [function(require, module, exports) {
            var debug = require('./debug')('Room.ajax');
            exports.get = function(url, callback) {
                var xhr;

                if (typeof XMLHttpRequest !== 'undefined') {
                    xhr = new XMLHttpRequest();
                } else {
                    var versions = [
                        "MSXML2.XmlHttp.5.0",
                        "MSXML2.XmlHttp.4.0",
                        "MSXML2.XmlHttp.3.0",
                        "MSXML2.XmlHttp.2.0",
                        "Microsoft.XmlHttp"
                    ];

                    for (var i = 0, len = versions.length; i < len; i++) {
                        try {
                            xhr = new ActiveXObject(versions[i]);
                            break;
                        } catch (ex) {
                            debug.error(ex.message);
                        }
                    }
                }

                xhr.onreadystatechange = function() {
                    if (xhr.readyState < 4 ||  xhr.status !== 200) {
                        debug.warn('XMLHttpRequest not ready yet');
                        return;
                    }

                    if (xhr.readyState === 4) {
                        callback(xhr);
                    }
                };

                xhr.open('GET', url, true);
                xhr.send('');
            }

        }, {
            "./debug": 20
        }],
        19: [function(require, module, exports) {
            /**
             * Checks if a string starts with '$' or underscore '_'
             * @param {String} val      Input
             * @return {Boolean}
             */
            exports.isReserved = function(val) {
                var c = (val + '').charCodeAt(0);
                return c === 0x24 || c === 0x5F;
            }

            /**
             * Transform a string to uppercase
             * @param  {String} c
             * @return {String}
             */
            function toUpper(_, c) {
                return c ? c.toUpperCase() : '';
            }

            /**
             * Camelize a hyphen-delmited string.
             * @param {String} str      Hyphed Input
             * @return {String}
             */
            exports.camelize = function(hyphed) {
                return hyphed.replace(/-(\w)/g, toUpper);
            }

            /**
             * Hyphenate a camelCase string.
             * @param {String} camel    Camelcase Input
             * @return {String}
             */
            exports.hyphenate = function(camel) {
                return camel
                    .replace(/([a-z\d])([A-Z])/g, '$1-$2')
                    .toLowerCase();
            }

            /**
             * Simple bindings even faster than native implementation
             * @param {Function} fn
             * @param {Object} ctx
             * @return {Function}
             */
            exports.bind = function(handle, context) {
                return function(a) {
                    var size = arguments.length
                    return size ? size > 1 ? handle.apply(context, arguments) : handle.call(context, a) : handle.call(context);
                };
            }

            /**
             * Mix properties into target object.
             * @param {Object} to
             * @param {Object} from
             */
            exports.mixin = function(to, from) {
                for (var key in from) {
                    to[key] = from[key]
                }
                return to;
            }

            /**
             * Check if a needle exists in an array
             * @param  {Array} arr
             * @param  {String} needle
             * @return {Boolean}
             */
            exports.contains = function(arr, needle) {
                for (var i in arr) {
                    if (arr[i] === needle) {
                        return true;
                    }
                }
                return false;
            }

        }, {}],
        20: [function(require, module, exports) {
            var chalk = require('chalk');

            /**
             * Easy debugging wrapped-up in a class,
             * set loglevel with the second parameter;
             *
             *   -1  Silent mode (hide everything)
             *    0  Display only errors
             *    1  Display warnings and errors
             *    2  Display warnings, errors and infos
             *    3  Display everything
             *
             * @param {String} namespace
             * @param {Integer} level
             */
            function RoomDebugger(namespace, level) {
                this.namespace = namespace || '<unknown>';
                this.enabled = true;
                this.level = level || 0;
                this.env = 'browser';
                this.writers = {
                    browser: {
                        log: function(str) {
                            if (level <= 3) {
                                return;
                            }
                            console.log(str);
                        },
                        error: function(str) {
                            if (level <= 0) {
                                return;
                            }
                            console.error(str);
                        },
                        warn: function(str) {
                            if (level <= 1) {
                                return;
                            }
                            console.warn(str);
                        },
                        info: function(str) {
                            if (level <= 2) {
                                return;
                            }
                            console.info(str);
                        },
                        success: function(str) {
                            if (level <= 3) {
                                return;
                            }
                            console.succes(str);
                        }
                    },
                    node: {
                        log: function(str) {
                            console.log(str);
                        },
                        error: function(str) {
                            console.log(chalk.red(str));
                        },
                        warn: function(str) {
                            console.log(chalk.yellow(str));
                        },
                        info: function(str) {
                            console.log(chalk.cyan(str));
                        },
                        success: function(str) {
                            console.log(chalk.green(str));
                        }
                    }
                }
            }

            RoomDebugger.prototype._env = function(environement) {
                this.env = environement;
            };

            RoomDebugger.prototype._out = function(mode, message) {
                if (this.enabled && this.level > -1) {
                    var stdout = this.writers[this.env][mode];
                    if (typeof stdout === 'function') {
                        stdout('[' + this.namespace + '] ' + message);
                    } else {
                        try {
                            stdout.apply(console, '[' + this.namespace + '] ' + message);
                        } catch (ex) {
                            throw new Error(ex);
                        }
                    }
                }
            };

            RoomDebugger.prototype.start = function(subspace) {
                if (console.group) {
                    if (this.level > 0) {
                        console.group(this.namespace + (subspace ? '.' + subspace : ''));
                    }
                }
            };

            RoomDebugger.prototype.end = function() {
                if (console.groupEnd) {
                    if (this.level > 0) {
                        console.groupEnd();
                    }
                }
            };

            RoomDebugger.prototype.log = function(message) {
                this._out('log', message);
            };

            RoomDebugger.prototype.warn = function(message) {
                this._out('warn', message);
            };

            RoomDebugger.prototype.info = function(message) {
                this._out('info', message);
            };

            RoomDebugger.prototype.error = function(message) {
                this._out('error', message);
            };

            RoomDebugger.prototype.success = function(message) {
                this._out('success', message);
            };

            exports = module.exports = function(namespace, level) {
                return new RoomDebugger(namespace, level);
            };

        }, {
            "chalk": 2
        }],
        21: [function(require, module, exports) {
            var config = require('./../config');

            /**
             * Getting and setting attributes on a node
             * @param  {Node} node
             * @param  {String} key
             * @param  {String} val
             * @return {?String}
             */
            exports.attr = function(node, key, val) {
                key = config.prefix + key;
                if (!val && node) {
                    return node.getAttribute(key);
                } else if (node && key && val) {
                    return node.setAttribute(key, val);
                }
            };

            /**
             * Insert node before target
             * @param {Node} node
             * @param {Node} target
             */
            exports.before = function(node, target) {
                target.parentNode.insertBefore(node, target);
            }

            /**
             * Insert node after target
             * @param {Node} node
             * @param {Node} target
             */
            exports.after = function(node, target) {
                if (target.nextSibling) {
                    exports.before(node, target.nextSibling);
                } else {
                    target.parentNode.appendChild(node);
                }
            }

            /**
             * Remove node from DOM
             * @param {Node} node
             */
            exports.remove = function(node) {
                node.parentNode.removeChild(node);
            }

            /**
             * Prepend node to target
             *
             * @param {Node} node
             * @param {Node} target
             */

            exports.prepend = function(node, target) {
                if (target.firstChild) {
                    exports.before(node, target.firstChild);
                } else {
                    target.appendChild(node);
                }
            }

            /**
             * Replace target with node
             * @param {Node} target
             * @param {Node} node
             */
            exports.replace = function(target, node) {
                var parent = target.parentNode;
                if (parent) {
                    parent.replaceChild(node, target);
                }
            }

            exports.on = function(node, event, handler) {
                if (node.addEventListener) {
                    node.addEventListener(event, handler, false);
                } else if (node.attachEvent) {
                    node.attachEvent(event, handler);
                }
            }


            /**
             * Remove event listener shorthand
             * @param {Node} node
             * @param {String} event
             * @param {Function} handler
             */
            exports.off = function(node, event, handler) {
                if (node.removeEventListener) {
                    node.removeEventListener(event, handler);
                } else if (node.detachEvent) {
                    node.detachEvent(event, handler);
                }
            }

            /**
             * Add class with compatibility for IE & SVG
             * @param {Node} node
             * @param {Strong} cls
             */
            exports.addClass = function(node, cls) {
                if (node.classList) {
                    node.classList.add(cls);
                } else {
                    var cur = ' ' + (node.getAttribute('class') || '') + ' ';
                    if (cur.indexOf(' ' + cls + ' ') < 0) {
                        node.setAttribute('class', (cur + cls).trim());
                    }
                }
            }

            /**
             * Remove class with compatibility for IE & SVG
             * @param {Node} node
             * @param {Strong} cls
             */
            exports.removeClass = function(node, cls) {
                if (node.classList) {
                    node.classList.remove(cls);
                } else {
                    var cur = ' ' + (node.getAttribute('class') || '') + ' ';
                    var tar = ' ' + cls + ' ';
                    while (cur.indexOf(tar) >= 0) {
                        cur = cur.replace(tar, ' ');
                    }
                    node.setAttribute('class', cur.trim());
                }
            }

        }, {
            "./../config": 13
        }],
        22: [function(require, module, exports) {
            var core = require('./core');
            core.mixin(exports, core);
            core.mixin(exports, require('./query'));
            core.mixin(exports.$, require('./dom'));
            exports.debug = require('./debug');
            exports.ajax = require('./ajax');

        }, {
            "./ajax": 18,
            "./core": 19,
            "./debug": 20,
            "./dom": 21,
            "./query": 23
        }],
        23: [function(require, module, exports) {
            /**
             * Custom and mini-implementation of jQuery selectors
             * which helps to select nodes in the browser
             * @param  {string} selector    CSS2/3 Selector
             * @return {Node}               0, 1 or multiple Nodes
             */
            var query = function(selector) {
                var matches = {
                        '#': 'getElementById', // $('#myId')
                        '.': 'getElementsByClassName', // $('.myClass')
                        '@': 'getElementsByName', // $('@myName')
                        '=': 'getElementsByTagName', // $('=body')
                        '?': 'querySelectorAll' // $('?anything')
                    },
                    rex = /[=#@.*]/.exec(selector)[0];
                var nodes = document[matches[rex]](selector.split(rex)[1]);
                return nodes.length > 1 ? nodes : nodes[0];
            };

            exports.$ = query;

        }, {}]
    }, {}, [17])(17)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NoYWxrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWxrL25vZGVfbW9kdWxlcy9hbnNpLXN0eWxlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFsay9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2hhbGsvbm9kZV9tb2R1bGVzL2hhcy1hbnNpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWxrL25vZGVfbW9kdWxlcy9oYXMtYW5zaS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFsay9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFsay9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVzdGFjaGUvbXVzdGFjaGUuanMiLCIvQXBwbGljYXRpb25zL01BTVAvaHRkb2NzL212dm0vc3JjL2FwcC5qcyIsIi9BcHBsaWNhdGlvbnMvTUFNUC9odGRvY3MvbXZ2bS9zcmMvY29tcGlsZXIuanMiLCIvQXBwbGljYXRpb25zL01BTVAvaHRkb2NzL212dm0vc3JjL2NvbmZpZy5qcyIsIi9BcHBsaWNhdGlvbnMvTUFNUC9odGRvY3MvbXZ2bS9zcmMvZGVwZW5kZW5jeS5qcyIsIi9BcHBsaWNhdGlvbnMvTUFNUC9odGRvY3MvbXZ2bS9zcmMvZWxlbWVudC5qcyIsIi9BcHBsaWNhdGlvbnMvTUFNUC9odGRvY3MvbXZ2bS9zcmMvZmFjdG9yeS5qcyIsIi9BcHBsaWNhdGlvbnMvTUFNUC9odGRvY3MvbXZ2bS9zcmMvaW5kZXguanMiLCIvQXBwbGljYXRpb25zL01BTVAvaHRkb2NzL212dm0vc3JjL3V0aWwvYWpheC5qcyIsIi9BcHBsaWNhdGlvbnMvTUFNUC9odGRvY3MvbXZ2bS9zcmMvdXRpbC9jb3JlLmpzIiwiL0FwcGxpY2F0aW9ucy9NQU1QL2h0ZG9jcy9tdnZtL3NyYy91dGlsL2RlYnVnLmpzIiwiL0FwcGxpY2F0aW9ucy9NQU1QL2h0ZG9jcy9tdnZtL3NyYy91dGlsL2RvbS5qcyIsIi9BcHBsaWNhdGlvbnMvTUFNUC9odGRvY3MvbXZ2bS9zcmMvdXRpbC9pbmRleC5qcyIsIi9BcHBsaWNhdGlvbnMvTUFNUC9odGRvY3MvbXZ2bS9zcmMvdXRpbC9xdWVyeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNubkJBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM3QixJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDckMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGNBQWMs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QUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNELE9BQU8sS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMvQyxDQUFDLENBQUM7O0FBRUYsT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZXNjYXBlU3RyaW5nUmVnZXhwID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcbnZhciBhbnNpU3R5bGVzID0gcmVxdWlyZSgnYW5zaS1zdHlsZXMnKTtcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG52YXIgaGFzQW5zaSA9IHJlcXVpcmUoJ2hhcy1hbnNpJyk7XG52YXIgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG52YXIgZGVmaW5lUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBpc1NpbXBsZVdpbmRvd3NUZXJtID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAhL154dGVybS9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSk7XG5cbmZ1bmN0aW9uIENoYWxrKG9wdGlvbnMpIHtcblx0Ly8gZGV0ZWN0IG1vZGUgaWYgbm90IHNldCBtYW51YWxseVxuXHR0aGlzLmVuYWJsZWQgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHN1cHBvcnRzQ29sb3IgOiBvcHRpb25zLmVuYWJsZWQ7XG59XG5cbi8vIHVzZSBicmlnaHQgYmx1ZSBvbiBXaW5kb3dzIGFzIHRoZSBub3JtYWwgYmx1ZSBjb2xvciBpcyBpbGxlZ2libGVcbmlmIChpc1NpbXBsZVdpbmRvd3NUZXJtKSB7XG5cdGFuc2lTdHlsZXMuYmx1ZS5vcGVuID0gJ1xcdTAwMWJbOTRtJztcbn1cblxudmFyIHN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRPYmplY3Qua2V5cyhhbnNpU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRhbnNpU3R5bGVzW2tleV0uY2xvc2VSZSA9IG5ldyBSZWdFeHAoZXNjYXBlU3RyaW5nUmVnZXhwKGFuc2lTdHlsZXNba2V5XS5jbG9zZSksICdnJyk7XG5cblx0XHRyZXRba2V5XSA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gYnVpbGQuY2FsbCh0aGlzLCB0aGlzLl9zdHlsZXMuY29uY2F0KGtleSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xuXG5cdHJldHVybiByZXQ7XG59KSgpO1xuXG52YXIgcHJvdG8gPSBkZWZpbmVQcm9wcyhmdW5jdGlvbiBjaGFsaygpIHt9LCBzdHlsZXMpO1xuXG5mdW5jdGlvbiBidWlsZChfc3R5bGVzKSB7XG5cdHZhciBidWlsZGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBhcHBseVN0eWxlLmFwcGx5KGJ1aWxkZXIsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0YnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcblx0YnVpbGRlci5lbmFibGVkID0gdGhpcy5lbmFibGVkO1xuXHQvLyBfX3Byb3RvX18gaXMgdXNlZCBiZWNhdXNlIHdlIG11c3QgcmV0dXJuIGEgZnVuY3Rpb24sIGJ1dCB0aGVyZSBpc1xuXHQvLyBubyB3YXkgdG8gY3JlYXRlIGEgZnVuY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBwcm90b3R5cGUuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cdGJ1aWxkZXIuX19wcm90b19fID0gcHJvdG87XG5cblx0cmV0dXJuIGJ1aWxkZXI7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoKSB7XG5cdC8vIHN1cHBvcnQgdmFyYWdzLCBidXQgc2ltcGx5IGNhc3QgdG8gc3RyaW5nIGluIGNhc2UgdGhlcmUncyBvbmx5IG9uZSBhcmdcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG5cdHZhciBzdHIgPSBhcmdzTGVuICE9PSAwICYmIFN0cmluZyhhcmd1bWVudHNbMF0pO1xuXG5cdGlmIChhcmdzTGVuID4gMSkge1xuXHRcdC8vIGRvbid0IHNsaWNlIGBhcmd1bWVudHNgLCBpdCBwcmV2ZW50cyB2OCBvcHRpbWl6YXRpb25zXG5cdFx0Zm9yICh2YXIgYSA9IDE7IGEgPCBhcmdzTGVuOyBhKyspIHtcblx0XHRcdHN0ciArPSAnICcgKyBhcmdzW2FdO1xuXHRcdH1cblx0fVxuXG5cdGlmICghdGhpcy5lbmFibGVkIHx8ICFzdHIpIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0dmFyIG5lc3RlZFN0eWxlcyA9IHRoaXMuX3N0eWxlcztcblx0dmFyIGkgPSBuZXN0ZWRTdHlsZXMubGVuZ3RoO1xuXG5cdC8vIFR1cm5zIG91dCB0aGF0IG9uIFdpbmRvd3MgZGltbWVkIGdyYXkgdGV4dCBiZWNvbWVzIGludmlzaWJsZSBpbiBjbWQuZXhlLFxuXHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL2lzc3Vlcy81OFxuXHQvLyBJZiB3ZSdyZSBvbiBXaW5kb3dzIGFuZCB3ZSdyZSBkZWFsaW5nIHdpdGggYSBncmF5IGNvbG9yLCB0ZW1wb3JhcmlseSBtYWtlICdkaW0nIGEgbm9vcC5cblx0dmFyIG9yaWdpbmFsRGltID0gYW5zaVN0eWxlcy5kaW0ub3Blbjtcblx0aWYgKGlzU2ltcGxlV2luZG93c1Rlcm0gJiYgKG5lc3RlZFN0eWxlcy5pbmRleE9mKCdncmF5JykgIT09IC0xIHx8IG5lc3RlZFN0eWxlcy5pbmRleE9mKCdncmV5JykgIT09IC0xKSkge1xuXHRcdGFuc2lTdHlsZXMuZGltLm9wZW4gPSAnJztcblx0fVxuXG5cdHdoaWxlIChpLS0pIHtcblx0XHR2YXIgY29kZSA9IGFuc2lTdHlsZXNbbmVzdGVkU3R5bGVzW2ldXTtcblxuXHRcdC8vIFJlcGxhY2UgYW55IGluc3RhbmNlcyBhbHJlYWR5IHByZXNlbnQgd2l0aCBhIHJlLW9wZW5pbmcgY29kZVxuXHRcdC8vIG90aGVyd2lzZSBvbmx5IHRoZSBwYXJ0IG9mIHRoZSBzdHJpbmcgdW50aWwgc2FpZCBjbG9zaW5nIGNvZGVcblx0XHQvLyB3aWxsIGJlIGNvbG9yZWQsIGFuZCB0aGUgcmVzdCB3aWxsIHNpbXBseSBiZSAncGxhaW4nLlxuXHRcdHN0ciA9IGNvZGUub3BlbiArIHN0ci5yZXBsYWNlKGNvZGUuY2xvc2VSZSwgY29kZS5vcGVuKSArIGNvZGUuY2xvc2U7XG5cdH1cblxuXHQvLyBSZXNldCB0aGUgb3JpZ2luYWwgJ2RpbScgaWYgd2UgY2hhbmdlZCBpdCB0byB3b3JrIGFyb3VuZCB0aGUgV2luZG93cyBkaW1tZWQgZ3JheSBpc3N1ZS5cblx0YW5zaVN0eWxlcy5kaW0ub3BlbiA9IG9yaWdpbmFsRGltO1xuXG5cdHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXRbbmFtZV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgW25hbWVdKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufVxuXG5kZWZpbmVQcm9wcyhDaGFsay5wcm90b3R5cGUsIGluaXQoKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENoYWxrKCk7XG5tb2R1bGUuZXhwb3J0cy5zdHlsZXMgPSBhbnNpU3R5bGVzO1xubW9kdWxlLmV4cG9ydHMuaGFzQ29sb3IgPSBoYXNBbnNpO1xubW9kdWxlLmV4cG9ydHMuc3RyaXBDb2xvciA9IHN0cmlwQW5zaTtcbm1vZHVsZS5leHBvcnRzLnN1cHBvcnRzQ29sb3IgPSBzdXBwb3J0c0NvbG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NlbWJsZVN0eWxlcyAoKSB7XG5cdHZhciBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXJzOiB7XG5cdFx0XHRyZXNldDogWzAsIDBdLFxuXHRcdFx0Ym9sZDogWzEsIDIyXSwgLy8gMjEgaXNuJ3Qgd2lkZWx5IHN1cHBvcnRlZCBhbmQgMjIgZG9lcyB0aGUgc2FtZSB0aGluZ1xuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yczoge1xuXHRcdFx0YmxhY2s6IFszMCwgMzldLFxuXHRcdFx0cmVkOiBbMzEsIDM5XSxcblx0XHRcdGdyZWVuOiBbMzIsIDM5XSxcblx0XHRcdHllbGxvdzogWzMzLCAzOV0sXG5cdFx0XHRibHVlOiBbMzQsIDM5XSxcblx0XHRcdG1hZ2VudGE6IFszNSwgMzldLFxuXHRcdFx0Y3lhbjogWzM2LCAzOV0sXG5cdFx0XHR3aGl0ZTogWzM3LCAzOV0sXG5cdFx0XHRncmF5OiBbOTAsIDM5XVxuXHRcdH0sXG5cdFx0YmdDb2xvcnM6IHtcblx0XHRcdGJnQmxhY2s6IFs0MCwgNDldLFxuXHRcdFx0YmdSZWQ6IFs0MSwgNDldLFxuXHRcdFx0YmdHcmVlbjogWzQyLCA0OV0sXG5cdFx0XHRiZ1llbGxvdzogWzQzLCA0OV0sXG5cdFx0XHRiZ0JsdWU6IFs0NCwgNDldLFxuXHRcdFx0YmdNYWdlbnRhOiBbNDUsIDQ5XSxcblx0XHRcdGJnQ3lhbjogWzQ2LCA0OV0sXG5cdFx0XHRiZ1doaXRlOiBbNDcsIDQ5XVxuXHRcdH1cblx0fTtcblxuXHQvLyBmaXggaHVtYW5zXG5cdHN0eWxlcy5jb2xvcnMuZ3JleSA9IHN0eWxlcy5jb2xvcnMuZ3JheTtcblxuXHRPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwTmFtZSkge1xuXHRcdHZhciBncm91cCA9IHN0eWxlc1tncm91cE5hbWVdO1xuXG5cdFx0T2JqZWN0LmtleXMoZ3JvdXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuXHRcdFx0dmFyIHN0eWxlID0gZ3JvdXBbc3R5bGVOYW1lXTtcblxuXHRcdFx0c3R5bGVzW3N0eWxlTmFtZV0gPSBncm91cFtzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiAnXFx1MDAxYlsnICsgc3R5bGVbMF0gKyAnbScsXG5cdFx0XHRcdGNsb3NlOiAnXFx1MDAxYlsnICsgc3R5bGVbMV0gKyAnbSdcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGFzc2VtYmxlU3R5bGVzXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGNoT3BlcmF0b3JzUmUgPSAvW3xcXFxce30oKVtcXF1eJCsqPy5dL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0cmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICAnXFxcXCQmJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKTtcbnZhciByZSA9IG5ldyBSZWdFeHAoYW5zaVJlZ2V4KCkuc291cmNlKTsgLy8gcmVtb3ZlIHRoZSBgZ2AgZmxhZ1xubW9kdWxlLmV4cG9ydHMgPSByZS50ZXN0LmJpbmQocmUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1PUlpjZi1ucXJ5PT48XS9nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcmd2ID0gcHJvY2Vzcy5hcmd2O1xuXG52YXIgdGVybWluYXRvciA9IGFyZ3YuaW5kZXhPZignLS0nKTtcbnZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGZsYWcpIHtcblx0ZmxhZyA9ICctLScgKyBmbGFnO1xuXHR2YXIgcG9zID0gYXJndi5pbmRleE9mKGZsYWcpO1xuXHRyZXR1cm4gcG9zICE9PSAtMSAmJiAodGVybWluYXRvciAhPT0gLTEgPyBwb3MgPCB0ZXJtaW5hdG9yIDogdHJ1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICgnRk9SQ0VfQ09MT1InIGluIHByb2Nlc3MuZW52KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnbm8tY29sb3InKSB8fFxuXHRcdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLmVudi5URVJNID09PSAnZHVtYicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn0pKCk7XG4iLCIvKiFcbiAqIG11c3RhY2hlLmpzIC0gTG9naWMtbGVzcyB7e211c3RhY2hlfX0gdGVtcGxhdGVzIHdpdGggSmF2YVNjcmlwdFxuICogaHR0cDovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qc1xuICovXG5cbi8qZ2xvYmFsIGRlZmluZTogZmFsc2UgTXVzdGFjaGU6IHRydWUqL1xuXG4oZnVuY3Rpb24gZGVmaW5lTXVzdGFjaGUgKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgdHlwZW9mIGV4cG9ydHMubm9kZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgZmFjdG9yeShleHBvcnRzKTsgLy8gQ29tbW9uSlNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpOyAvLyBBTURcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuTXVzdGFjaGUgPSB7fTtcbiAgICBmYWN0b3J5KE11c3RhY2hlKTsgLy8gc2NyaXB0LCB3c2gsIGFzcFxuICB9XG59KHRoaXMsIGZ1bmN0aW9uIG11c3RhY2hlRmFjdG9yeSAobXVzdGFjaGUpIHtcblxuICB2YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheVBvbHlmaWxsIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vcmUgY29ycmVjdCB0eXBlb2Ygc3RyaW5nIGhhbmRsaW5nIGFycmF5XG4gICAqIHdoaWNoIG5vcm1hbGx5IHJldHVybnMgdHlwZW9mICdvYmplY3QnXG4gICAqL1xuICBmdW5jdGlvbiB0eXBlU3RyIChvYmopIHtcbiAgICByZXR1cm4gaXNBcnJheShvYmopID8gJ2FycmF5JyA6IHR5cGVvZiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAgKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOdWxsIHNhZmUgd2F5IG9mIGNoZWNraW5nIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCxcbiAgICogaW5jbHVkaW5nIGl0cyBwcm90b3R5cGUsIGhhcyBhIGdpdmVuIHByb3BlcnR5XG4gICAqL1xuICBmdW5jdGlvbiBoYXNQcm9wZXJ0eSAob2JqLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAocHJvcE5hbWUgaW4gb2JqKTtcbiAgfVxuXG4gIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vaXNzdWVzLmFwYWNoZS5vcmcvamlyYS9icm93c2UvQ09VQ0hEQi01NzdcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODlcbiAgdmFyIHJlZ0V4cFRlc3QgPSBSZWdFeHAucHJvdG90eXBlLnRlc3Q7XG4gIGZ1bmN0aW9uIHRlc3RSZWdFeHAgKHJlLCBzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVnRXhwVGVzdC5jYWxsKHJlLCBzdHJpbmcpO1xuICB9XG5cbiAgdmFyIG5vblNwYWNlUmUgPSAvXFxTLztcbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChzdHJpbmcpIHtcbiAgICByZXR1cm4gIXRlc3RSZWdFeHAobm9uU3BhY2VSZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICcvJzogJyYjeDJGOydcbiAgfTtcblxuICBmdW5jdGlvbiBlc2NhcGVIdG1sIChzdHJpbmcpIHtcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvWyY8PlwiJ1xcL10vZywgZnVuY3Rpb24gZnJvbUVudGl0eU1hcCAocykge1xuICAgICAgcmV0dXJuIGVudGl0eU1hcFtzXTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3aGl0ZVJlID0gL1xccyovO1xuICB2YXIgc3BhY2VSZSA9IC9cXHMrLztcbiAgdmFyIGVxdWFsc1JlID0gL1xccyo9LztcbiAgdmFyIGN1cmx5UmUgPSAvXFxzKlxcfS87XG4gIHZhciB0YWdSZSA9IC8jfFxcXnxcXC98PnxcXHt8Jnw9fCEvO1xuXG4gIC8qKlxuICAgKiBCcmVha3MgdXAgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgc3RyaW5nIGludG8gYSB0cmVlIG9mIHRva2Vucy4gSWYgdGhlIGB0YWdzYFxuICAgKiBhcmd1bWVudCBpcyBnaXZlbiBoZXJlIGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gc3RyaW5nIHZhbHVlczogdGhlXG4gICAqIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSAoZS5nLiBbIFwiPCVcIiwgXCIlPlwiIF0pLiBPZlxuICAgKiBjb3Vyc2UsIHRoZSBkZWZhdWx0IGlzIHRvIHVzZSBtdXN0YWNoZXMgKGkuZS4gbXVzdGFjaGUudGFncykuXG4gICAqXG4gICAqIEEgdG9rZW4gaXMgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCA0IGVsZW1lbnRzLiBUaGUgZmlyc3QgZWxlbWVudCBpcyB0aGVcbiAgICogbXVzdGFjaGUgc3ltYm9sIHRoYXQgd2FzIHVzZWQgaW5zaWRlIHRoZSB0YWcsIGUuZy4gXCIjXCIgb3IgXCImXCIuIElmIHRoZSB0YWdcbiAgICogZGlkIG5vdCBjb250YWluIGEgc3ltYm9sIChpLmUuIHt7bXlWYWx1ZX19KSB0aGlzIGVsZW1lbnQgaXMgXCJuYW1lXCIuIEZvclxuICAgKiBhbGwgdGV4dCB0aGF0IGFwcGVhcnMgb3V0c2lkZSBhIHN5bWJvbCB0aGlzIGVsZW1lbnQgaXMgXCJ0ZXh0XCIuXG4gICAqXG4gICAqIFRoZSBzZWNvbmQgZWxlbWVudCBvZiBhIHRva2VuIGlzIGl0cyBcInZhbHVlXCIuIEZvciBtdXN0YWNoZSB0YWdzIHRoaXMgaXNcbiAgICogd2hhdGV2ZXIgZWxzZSB3YXMgaW5zaWRlIHRoZSB0YWcgYmVzaWRlcyB0aGUgb3BlbmluZyBzeW1ib2wuIEZvciB0ZXh0IHRva2Vuc1xuICAgKiB0aGlzIGlzIHRoZSB0ZXh0IGl0c2VsZi5cbiAgICpcbiAgICogVGhlIHRoaXJkIGFuZCBmb3VydGggZWxlbWVudHMgb2YgdGhlIHRva2VuIGFyZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRpY2VzLFxuICAgKiByZXNwZWN0aXZlbHksIG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXG4gICAqXG4gICAqIFRva2VucyB0aGF0IGFyZSB0aGUgcm9vdCBub2RlIG9mIGEgc3VidHJlZSBjb250YWluIHR3byBtb3JlIGVsZW1lbnRzOiAxKSBhblxuICAgKiBhcnJheSBvZiB0b2tlbnMgaW4gdGhlIHN1YnRyZWUgYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgYXRcbiAgICogd2hpY2ggdGhlIGNsb3NpbmcgdGFnIGZvciB0aGF0IHNlY3Rpb24gYmVnaW5zLlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICBpZiAoIXRlbXBsYXRlKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgdmFyIHNlY3Rpb25zID0gW107ICAgICAvLyBTdGFjayB0byBob2xkIHNlY3Rpb24gdG9rZW5zXG4gICAgdmFyIHRva2VucyA9IFtdOyAgICAgICAvLyBCdWZmZXIgdG8gaG9sZCB0aGUgdG9rZW5zXG4gICAgdmFyIHNwYWNlcyA9IFtdOyAgICAgICAvLyBJbmRpY2VzIG9mIHdoaXRlc3BhY2UgdG9rZW5zIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgICB2YXIgaGFzVGFnID0gZmFsc2U7ICAgIC8vIElzIHRoZXJlIGEge3t0YWd9fSBvbiB0aGUgY3VycmVudCBsaW5lP1xuICAgIHZhciBub25TcGFjZSA9IGZhbHNlOyAgLy8gSXMgdGhlcmUgYSBub24tc3BhY2UgY2hhciBvbiB0aGUgY3VycmVudCBsaW5lP1xuXG4gICAgLy8gU3RyaXBzIGFsbCB3aGl0ZXNwYWNlIHRva2VucyBhcnJheSBmb3IgdGhlIGN1cnJlbnQgbGluZVxuICAgIC8vIGlmIHRoZXJlIHdhcyBhIHt7I3RhZ319IG9uIGl0IGFuZCBvdGhlcndpc2Ugb25seSBzcGFjZS5cbiAgICBmdW5jdGlvbiBzdHJpcFNwYWNlICgpIHtcbiAgICAgIGlmIChoYXNUYWcgJiYgIW5vblNwYWNlKSB7XG4gICAgICAgIHdoaWxlIChzcGFjZXMubGVuZ3RoKVxuICAgICAgICAgIGRlbGV0ZSB0b2tlbnNbc3BhY2VzLnBvcCgpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBoYXNUYWcgPSBmYWxzZTtcbiAgICAgIG5vblNwYWNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG9wZW5pbmdUYWdSZSwgY2xvc2luZ1RhZ1JlLCBjbG9zaW5nQ3VybHlSZTtcbiAgICBmdW5jdGlvbiBjb21waWxlVGFncyAodGFnc1RvQ29tcGlsZSkge1xuICAgICAgaWYgKHR5cGVvZiB0YWdzVG9Db21waWxlID09PSAnc3RyaW5nJylcbiAgICAgICAgdGFnc1RvQ29tcGlsZSA9IHRhZ3NUb0NvbXBpbGUuc3BsaXQoc3BhY2VSZSwgMik7XG5cbiAgICAgIGlmICghaXNBcnJheSh0YWdzVG9Db21waWxlKSB8fCB0YWdzVG9Db21waWxlLmxlbmd0aCAhPT0gMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZ3M6ICcgKyB0YWdzVG9Db21waWxlKTtcblxuICAgICAgb3BlbmluZ1RhZ1JlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVswXSkgKyAnXFxcXHMqJyk7XG4gICAgICBjbG9zaW5nVGFnUmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgICAgIGNsb3NpbmdDdXJseVJlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCgnfScgKyB0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgfVxuXG4gICAgY29tcGlsZVRhZ3ModGFncyB8fCBtdXN0YWNoZS50YWdzKTtcblxuICAgIHZhciBzY2FubmVyID0gbmV3IFNjYW5uZXIodGVtcGxhdGUpO1xuXG4gICAgdmFyIHN0YXJ0LCB0eXBlLCB2YWx1ZSwgY2hyLCB0b2tlbiwgb3BlblNlY3Rpb247XG4gICAgd2hpbGUgKCFzY2FubmVyLmVvcygpKSB7XG4gICAgICBzdGFydCA9IHNjYW5uZXIucG9zO1xuXG4gICAgICAvLyBNYXRjaCBhbnkgdGV4dCBiZXR3ZWVuIHRhZ3MuXG4gICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKG9wZW5pbmdUYWdSZSk7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCB2YWx1ZUxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2hyID0gdmFsdWUuY2hhckF0KGkpO1xuXG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjaHIpKSB7XG4gICAgICAgICAgICBzcGFjZXMucHVzaCh0b2tlbnMubGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2Vucy5wdXNoKFsgJ3RleHQnLCBjaHIsIHN0YXJ0LCBzdGFydCArIDEgXSk7XG4gICAgICAgICAgc3RhcnQgKz0gMTtcblxuICAgICAgICAgIC8vIENoZWNrIGZvciB3aGl0ZXNwYWNlIG9uIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgICAgaWYgKGNociA9PT0gJ1xcbicpXG4gICAgICAgICAgICBzdHJpcFNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2ggdGhlIG9wZW5pbmcgdGFnLlxuICAgICAgaWYgKCFzY2FubmVyLnNjYW4ob3BlbmluZ1RhZ1JlKSlcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGhhc1RhZyA9IHRydWU7XG5cbiAgICAgIC8vIEdldCB0aGUgdGFnIHR5cGUuXG4gICAgICB0eXBlID0gc2Nhbm5lci5zY2FuKHRhZ1JlKSB8fCAnbmFtZSc7XG4gICAgICBzY2FubmVyLnNjYW4od2hpdGVSZSk7XG5cbiAgICAgIC8vIEdldCB0aGUgdGFnIHZhbHVlLlxuICAgICAgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGVxdWFsc1JlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGVxdWFsc1JlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3snKSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ0N1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW4oY3VybHlSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICAgIHR5cGUgPSAnJic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hdGNoIHRoZSBjbG9zaW5nIHRhZy5cbiAgICAgIGlmICghc2Nhbm5lci5zY2FuKGNsb3NpbmdUYWdSZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgdGFnIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgICAgIHRva2VuID0gWyB0eXBlLCB2YWx1ZSwgc3RhcnQsIHNjYW5uZXIucG9zIF07XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0eXBlID09PSAnIycgfHwgdHlwZSA9PT0gJ14nKSB7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnLycpIHtcbiAgICAgICAgLy8gQ2hlY2sgc2VjdGlvbiBuZXN0aW5nLlxuICAgICAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgICAgIGlmICghb3BlblNlY3Rpb24pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbm9wZW5lZCBzZWN0aW9uIFwiJyArIHZhbHVlICsgJ1wiIGF0ICcgKyBzdGFydCk7XG5cbiAgICAgICAgaWYgKG9wZW5TZWN0aW9uWzFdICE9PSB2YWx1ZSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25hbWUnIHx8IHR5cGUgPT09ICd7JyB8fCB0eXBlID09PSAnJicpIHtcbiAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0YWdzIGZvciB0aGUgbmV4dCB0aW1lIGFyb3VuZC5cbiAgICAgICAgY29tcGlsZVRhZ3ModmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gb3BlbiBzZWN0aW9ucyB3aGVuIHdlJ3JlIGRvbmUuXG4gICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgIGlmIChvcGVuU2VjdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgcmV0dXJuIG5lc3RUb2tlbnMoc3F1YXNoVG9rZW5zKHRva2VucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmVzIHRoZSB2YWx1ZXMgb2YgY29uc2VjdXRpdmUgdGV4dCB0b2tlbnMgaW4gdGhlIGdpdmVuIGB0b2tlbnNgIGFycmF5XG4gICAqIHRvIGEgc2luZ2xlIHRva2VuLlxuICAgKi9cbiAgZnVuY3Rpb24gc3F1YXNoVG9rZW5zICh0b2tlbnMpIHtcbiAgICB2YXIgc3F1YXNoZWRUb2tlbnMgPSBbXTtcblxuICAgIHZhciB0b2tlbiwgbGFzdFRva2VuO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSAndGV4dCcgJiYgbGFzdFRva2VuICYmIGxhc3RUb2tlblswXSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuWzFdICs9IHRva2VuWzFdO1xuICAgICAgICAgIGxhc3RUb2tlblszXSA9IHRva2VuWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNxdWFzaGVkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxdWFzaGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1zIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCBpbnRvIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlIHdoZXJlXG4gICAqIHRva2VucyB0aGF0IHJlcHJlc2VudCBhIHNlY3Rpb24gaGF2ZSB0d28gYWRkaXRpb25hbCBpdGVtczogMSkgYW4gYXJyYXkgb2ZcbiAgICogYWxsIHRva2VucyB0aGF0IGFwcGVhciBpbiB0aGF0IHNlY3Rpb24gYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWxcbiAgICogdGVtcGxhdGUgdGhhdCByZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhhdCBzZWN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gbmVzdFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIG5lc3RlZFRva2VucyA9IFtdO1xuICAgIHZhciBjb2xsZWN0b3IgPSBuZXN0ZWRUb2tlbnM7XG4gICAgdmFyIHNlY3Rpb25zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIHNlY3Rpb247XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgIGNhc2UgJyMnOlxuICAgICAgY2FzZSAnXic6XG4gICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbGxlY3RvciA9IHRva2VuWzRdID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnLyc6XG4gICAgICAgIHNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcbiAgICAgICAgc2VjdGlvbls1XSA9IHRva2VuWzJdO1xuICAgICAgICBjb2xsZWN0b3IgPSBzZWN0aW9ucy5sZW5ndGggPiAwID8gc2VjdGlvbnNbc2VjdGlvbnMubGVuZ3RoIC0gMV1bNF0gOiBuZXN0ZWRUb2tlbnM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXN0ZWRUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogQSBzaW1wbGUgc3RyaW5nIHNjYW5uZXIgdGhhdCBpcyB1c2VkIGJ5IHRoZSB0ZW1wbGF0ZSBwYXJzZXIgdG8gZmluZFxuICAgKiB0b2tlbnMgaW4gdGVtcGxhdGUgc3RyaW5ncy5cbiAgICovXG4gIGZ1bmN0aW9uIFNjYW5uZXIgKHN0cmluZykge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMudGFpbCA9IHN0cmluZztcbiAgICB0aGlzLnBvcyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRhaWwgaXMgZW1wdHkgKGVuZCBvZiBzdHJpbmcpLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuZW9zID0gZnVuY3Rpb24gZW9zICgpIHtcbiAgICByZXR1cm4gdGhpcy50YWlsID09PSAnJztcbiAgfTtcblxuICAvKipcbiAgICogVHJpZXMgdG8gbWF0Y2ggdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICogUmV0dXJucyB0aGUgbWF0Y2hlZCB0ZXh0IGlmIGl0IGNhbiBtYXRjaCwgdGhlIGVtcHR5IHN0cmluZyBvdGhlcndpc2UuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5zY2FuID0gZnVuY3Rpb24gc2NhbiAocmUpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnRhaWwubWF0Y2gocmUpO1xuXG4gICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCAhPT0gMClcbiAgICAgIHJldHVybiAnJztcblxuICAgIHZhciBzdHJpbmcgPSBtYXRjaFswXTtcblxuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCk7XG4gICAgdGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNraXBzIGFsbCB0ZXh0IHVudGlsIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gY2FuIGJlIG1hdGNoZWQuIFJldHVybnNcbiAgICogdGhlIHNraXBwZWQgc3RyaW5nLCB3aGljaCBpcyB0aGUgZW50aXJlIHRhaWwgaWYgbm8gbWF0Y2ggY2FuIGJlIG1hZGUuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVW50aWwgPSBmdW5jdGlvbiBzY2FuVW50aWwgKHJlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50YWlsLnNlYXJjaChyZSksIG1hdGNoO1xuXG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgIGNhc2UgLTE6XG4gICAgICBtYXRjaCA9IHRoaXMudGFpbDtcbiAgICAgIHRoaXMudGFpbCA9ICcnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAwOlxuICAgICAgbWF0Y2ggPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtYXRjaCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhpbmRleCk7XG4gICAgfVxuXG4gICAgdGhpcy5wb3MgKz0gbWF0Y2gubGVuZ3RoO1xuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgcmVuZGVyaW5nIGNvbnRleHQgYnkgd3JhcHBpbmcgYSB2aWV3IG9iamVjdCBhbmRcbiAgICogbWFpbnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjb250ZXh0LlxuICAgKi9cbiAgZnVuY3Rpb24gQ29udGV4dCAodmlldywgcGFyZW50Q29udGV4dCkge1xuICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgdGhpcy5jYWNoZSA9IHsgJy4nOiB0aGlzLnZpZXcgfTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudENvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb250ZXh0IHVzaW5nIHRoZSBnaXZlbiB2aWV3IHdpdGggdGhpcyBjb250ZXh0XG4gICAqIGFzIHRoZSBwYXJlbnQuXG4gICAqL1xuICBDb250ZXh0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAodmlldykge1xuICAgIHJldHVybiBuZXcgQ29udGV4dCh2aWV3LCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIG5hbWUgaW4gdGhpcyBjb250ZXh0LCB0cmF2ZXJzaW5nXG4gICAqIHVwIHRoZSBjb250ZXh0IGhpZXJhcmNoeSBpZiB0aGUgdmFsdWUgaXMgYWJzZW50IGluIHRoaXMgY29udGV4dCdzIHZpZXcuXG4gICAqL1xuICBDb250ZXh0LnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiBsb29rdXAgKG5hbWUpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdmFsdWUgPSBjYWNoZVtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBuYW1lcywgaW5kZXgsIGxvb2t1cEhpdCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoY29udGV4dCkge1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICAgICAgdmFsdWUgPSBjb250ZXh0LnZpZXc7XG4gICAgICAgICAgbmFtZXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgaW5kZXggPSAwO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVXNpbmcgdGhlIGRvdCBub3Rpb24gcGF0aCBpbiBgbmFtZWAsIHdlIGRlc2NlbmQgdGhyb3VnaCB0aGVcbiAgICAgICAgICAgKiBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRvIGJlIGNlcnRhaW4gdGhhdCB0aGUgbG9va3VwIGhhcyBiZWVuIHN1Y2Nlc3NmdWwsIHdlIGhhdmUgdG9cbiAgICAgICAgICAgKiBjaGVjayBpZiB0aGUgbGFzdCBvYmplY3QgaW4gdGhlIHBhdGggYWN0dWFsbHkgaGFzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAqIHdlIGFyZSBsb29raW5nIGZvci4gV2Ugc3RvcmUgdGhlIHJlc3VsdCBpbiBgbG9va3VwSGl0YC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgaXMgc3BlY2lhbGx5IG5lY2Vzc2FyeSBmb3Igd2hlbiB0aGUgdmFsdWUgaGFzIGJlZW4gc2V0IHRvXG4gICAgICAgICAgICogYHVuZGVmaW5lZGAgYW5kIHdlIHdhbnQgdG8gYXZvaWQgbG9va2luZyB1cCBwYXJlbnQgY29udGV4dHMuXG4gICAgICAgICAgICoqL1xuICAgICAgICAgIHdoaWxlICh2YWx1ZSAhPSBudWxsICYmIGluZGV4IDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IG5hbWVzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KHZhbHVlLCBuYW1lc1tpbmRleF0pO1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW25hbWVzW2luZGV4KytdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBjb250ZXh0LnZpZXdbbmFtZV07XG4gICAgICAgICAgbG9va3VwSGl0ID0gaGFzUHJvcGVydHkoY29udGV4dC52aWV3LCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb29rdXBIaXQpXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICBjYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSlcbiAgICAgIHZhbHVlID0gdmFsdWUuY2FsbCh0aGlzLnZpZXcpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIFdyaXRlciBrbm93cyBob3cgdG8gdGFrZSBhIHN0cmVhbSBvZiB0b2tlbnMgYW5kIHJlbmRlciB0aGVtIHRvIGFcbiAgICogc3RyaW5nLCBnaXZlbiBhIGNvbnRleHQuIEl0IGFsc28gbWFpbnRhaW5zIGEgY2FjaGUgb2YgdGVtcGxhdGVzIHRvXG4gICAqIGF2b2lkIHRoZSBuZWVkIHRvIHBhcnNlIHRoZSBzYW1lIHRlbXBsYXRlIHR3aWNlLlxuICAgKi9cbiAgZnVuY3Rpb24gV3JpdGVyICgpIHtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoaXMgd3JpdGVyLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgdG9rZW5zXG4gICAqIHRoYXQgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHBhcnNlLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICh0ZW1wbGF0ZSwgdGFncykge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gICAgdmFyIHRva2VucyA9IGNhY2hlW3RlbXBsYXRlXTtcblxuICAgIGlmICh0b2tlbnMgPT0gbnVsbClcbiAgICAgIHRva2VucyA9IGNhY2hlW3RlbXBsYXRlXSA9IHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHRhZ3MpO1xuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfTtcblxuICAvKipcbiAgICogSGlnaC1sZXZlbCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCB3aXRoXG4gICAqIHRoZSBnaXZlbiBgdmlld2AuXG4gICAqXG4gICAqIFRoZSBvcHRpb25hbCBgcGFydGlhbHNgIGFyZ3VtZW50IG1heSBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcbiAgICogbmFtZXMgYW5kIHRlbXBsYXRlcyBvZiBwYXJ0aWFscyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0ZW1wbGF0ZS4gSXQgbWF5XG4gICAqIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbG9hZCBwYXJ0aWFsIHRlbXBsYXRlcyBvbiB0aGUgZmx5XG4gICAqIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZSBuYW1lIG9mIHRoZSBwYXJ0aWFsLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscykge1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnBhcnNlKHRlbXBsYXRlKTtcbiAgICB2YXIgY29udGV4dCA9ICh2aWV3IGluc3RhbmNlb2YgQ29udGV4dCkgPyB2aWV3IDogbmV3IENvbnRleHQodmlldyk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIHRlbXBsYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogTG93LWxldmVsIG1ldGhvZCB0aGF0IHJlbmRlcnMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIHVzaW5nXG4gICAqIHRoZSBnaXZlbiBgY29udGV4dGAgYW5kIGBwYXJ0aWFsc2AuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBgb3JpZ2luYWxUZW1wbGF0ZWAgaXMgb25seSBldmVyIHVzZWQgdG8gZXh0cmFjdCB0aGUgcG9ydGlvblxuICAgKiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB3YXMgY29udGFpbmVkIGluIGEgaGlnaGVyLW9yZGVyIHNlY3Rpb24uXG4gICAqIElmIHRoZSB0ZW1wbGF0ZSBkb2Vzbid0IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMsIHRoaXMgYXJndW1lbnQgbWF5XG4gICAqIGJlIG9taXR0ZWQuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclRva2VucyA9IGZ1bmN0aW9uIHJlbmRlclRva2VucyAodG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSkge1xuICAgIHZhciBidWZmZXIgPSAnJztcblxuICAgIHZhciB0b2tlbiwgc3ltYm9sLCB2YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgc3ltYm9sID0gdG9rZW5bMF07XG5cbiAgICAgIGlmIChzeW1ib2wgPT09ICcjJykgdmFsdWUgPSB0aGlzLnJlbmRlclNlY3Rpb24odG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ14nKSB2YWx1ZSA9IHRoaXMucmVuZGVySW52ZXJ0ZWQodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJz4nKSB2YWx1ZSA9IHRoaXMucmVuZGVyUGFydGlhbCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnJicpIHZhbHVlID0gdGhpcy51bmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICduYW1lJykgdmFsdWUgPSB0aGlzLmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICd0ZXh0JykgdmFsdWUgPSB0aGlzLnJhd1ZhbHVlKHRva2VuKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIHJlbmRlclNlY3Rpb24gKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYnVmZmVyID0gJyc7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlbmRlciBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgICAvLyBpbiB0aGUgY3VycmVudCBjb250ZXh0IGJ5IGhpZ2hlci1vcmRlciBzZWN0aW9ucy5cbiAgICBmdW5jdGlvbiBzdWJSZW5kZXIgKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gc2VsZi5yZW5kZXIodGVtcGxhdGUsIGNvbnRleHQsIHBhcnRpYWxzKTtcbiAgICB9XG5cbiAgICBpZiAoIXZhbHVlKSByZXR1cm47XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAodmFyIGogPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaiA8IHZhbHVlTGVuZ3RoOyArK2opIHtcbiAgICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWVbal0pLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWUpLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbFRlbXBsYXRlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucyB3aXRob3V0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZScpO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBwb3J0aW9uIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHRoZSBzZWN0aW9uIGNvbnRhaW5zLlxuICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKGNvbnRleHQudmlldywgb3JpZ2luYWxUZW1wbGF0ZS5zbGljZSh0b2tlblszXSwgdG9rZW5bNV0pLCBzdWJSZW5kZXIpO1xuXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlckludmVydGVkID0gZnVuY3Rpb24gcmVuZGVySW52ZXJ0ZWQgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSkge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgIC8vIFVzZSBKYXZhU2NyaXB0J3MgZGVmaW5pdGlvbiBvZiBmYWxzeS4gSW5jbHVkZSBlbXB0eSBhcnJheXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODZcbiAgICBpZiAoIXZhbHVlIHx8IChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJQYXJ0aWFsID0gZnVuY3Rpb24gcmVuZGVyUGFydGlhbCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzKSB7XG4gICAgaWYgKCFwYXJ0aWFscykgcmV0dXJuO1xuXG4gICAgdmFyIHZhbHVlID0gaXNGdW5jdGlvbihwYXJ0aWFscykgPyBwYXJ0aWFscyh0b2tlblsxXSkgOiBwYXJ0aWFsc1t0b2tlblsxXV07XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModGhpcy5wYXJzZSh2YWx1ZSksIGNvbnRleHQsIHBhcnRpYWxzLCB2YWx1ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS51bmVzY2FwZWRWYWx1ZSA9IGZ1bmN0aW9uIHVuZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLmVzY2FwZWRWYWx1ZSA9IGZ1bmN0aW9uIGVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gbXVzdGFjaGUuZXNjYXBlKHZhbHVlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJhd1ZhbHVlID0gZnVuY3Rpb24gcmF3VmFsdWUgKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuWzFdO1xuICB9O1xuXG4gIG11c3RhY2hlLm5hbWUgPSAnbXVzdGFjaGUuanMnO1xuICBtdXN0YWNoZS52ZXJzaW9uID0gJzIuMS4zJztcbiAgbXVzdGFjaGUudGFncyA9IFsgJ3t7JywgJ319JyBdO1xuXG4gIC8vIEFsbCBoaWdoLWxldmVsIG11c3RhY2hlLiogZnVuY3Rpb25zIHVzZSB0aGlzIHdyaXRlci5cbiAgdmFyIGRlZmF1bHRXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBtdXN0YWNoZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIuY2xlYXJDYWNoZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gdGVtcGxhdGUgaW4gdGhlIGRlZmF1bHQgd3JpdGVyIGFuZCByZXR1cm5zIHRoZVxuICAgKiBhcnJheSBvZiB0b2tlbnMgaXQgY29udGFpbnMuIERvaW5nIHRoaXMgYWhlYWQgb2YgdGltZSBhdm9pZHMgdGhlIG5lZWQgdG9cbiAgICogcGFyc2UgdGVtcGxhdGVzIG9uIHRoZSBmbHkgYXMgdGhleSBhcmUgcmVuZGVyZWQuXG4gICAqL1xuICBtdXN0YWNoZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICh0ZW1wbGF0ZSwgdGFncykge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnBhcnNlKHRlbXBsYXRlLCB0YWdzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYHRlbXBsYXRlYCB3aXRoIHRoZSBnaXZlbiBgdmlld2AgYW5kIGBwYXJ0aWFsc2AgdXNpbmcgdGhlXG4gICAqIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgbXVzdGFjaGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSEgVGVtcGxhdGUgc2hvdWxkIGJlIGEgXCJzdHJpbmdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2J1dCBcIicgKyB0eXBlU3RyKHRlbXBsYXRlKSArICdcIiB3YXMgZ2l2ZW4gYXMgdGhlIGZpcnN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnQgZm9yIG11c3RhY2hlI3JlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNC54LixcbiAgLyplc2xpbnQtZGlzYWJsZSAqLyAvLyBlc2xpbnQgd2FudHMgY2FtZWwgY2FzZWQgZnVuY3Rpb24gbmFtZVxuICBtdXN0YWNoZS50b19odG1sID0gZnVuY3Rpb24gdG9faHRtbCAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBzZW5kKSB7XG4gICAgLyplc2xpbnQtZW5hYmxlKi9cblxuICAgIHZhciByZXN1bHQgPSBtdXN0YWNoZS5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHNlbmQpKSB7XG4gICAgICBzZW5kKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgZXNjYXBpbmcgZnVuY3Rpb24gc28gdGhhdCB0aGUgdXNlciBtYXkgb3ZlcnJpZGUgaXQuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMjQ0XG4gIG11c3RhY2hlLmVzY2FwZSA9IGVzY2FwZUh0bWw7XG5cbiAgLy8gRXhwb3J0IHRoZXNlIG1haW5seSBmb3IgdGVzdGluZywgYnV0IGFsc28gZm9yIGFkdmFuY2VkIHVzYWdlLlxuICBtdXN0YWNoZS5TY2FubmVyID0gU2Nhbm5lcjtcbiAgbXVzdGFjaGUuQ29udGV4dCA9IENvbnRleHQ7XG4gIG11c3RhY2hlLldyaXRlciA9IFdyaXRlcjtcblxufSkpO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4vY29tcGlsZXInKTtcbnZhciBpbmplY3QgPSByZXF1aXJlKCcuL2RlcGVuZGVuY3knKS5pbmplY3Q7XG52YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4vZWxlbWVudCcpO1xudmFyIGFwcGZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3RvcnknKTtcbnZhciBkZWJ1ZyA9IHV0aWwuZGVidWcoJ1Jvb20uYXBwbGljYXRpb24nLCAwKTtcblxuZnVuY3Rpb24gUm9vbUFwcGxpY2F0aW9uKG5hbWUsIGRlcHMsIG9wdHMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgIHRoaXMuc2VydmljZXMgPSB7fTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG5cbiAgICBpZighQXJyYXkuaXNBcnJheShkZXBzKSAmJiB0eXBlb2YgZGVwcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0cyA9IGRlcHM7XG4gICAgICAgIGRlcHMgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcHMgfHzCoFtdO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdHMgfHzCoHt9O1xuXG4gICAgdGhpcy5yb3V0ZXIgPSB7XG4gICAgICAgIHVybDogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBmaWxlbmFtZTogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJlc29sdmUgZGVwZW5kZW5jaWVzIGZvciBhcHBsaWNhdGlvbiBtb2R1bGVcbiAgICB0aGlzLmNoZWNrRGVwZW5kZW5jaWVzKCk7XG59O1xuXG5Sb29tQXBwbGljYXRpb24ucHJvdG90eXBlLmNoZWNrRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGRlYnVnLnN0YXJ0KCdjaGVja0RlcGVuZGVuY2llcycpO1xuICAgIHNlbGYuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7XG4gICAgICAgIGlmKCF3aW5kb3dbZGVwXSkge1xuICAgICAgICAgICAgZGVidWcuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ0RlcGVuZGVuY3kgJyArIGRlcCArICcgaXMgcmVxdWlyZWQgZm9yIHVzaW5nICcgK1xuICAgICAgICAgICAgICAgICdtb2R1bGUgXFwnJyArIHNlbGYubmFtZSArICdcXCcnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVidWcuaW5mbygnTm8gZGVwZW5kZW5jeSBmb3VuZCBvciBldmVyeXRoaW5nIGluY2x1ZGVkJyk7XG4gICAgZGVidWcuZW5kKCk7XG59O1xuXG5Sb29tQXBwbGljYXRpb24ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24obmFtZSwgZmFjdG9yeSkge1xuICAgIGRlYnVnLnN0YXJ0KCdyZWdpc3RlcicpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaGFuZGxlciwgZGVwcywgaW5qZWN0b3IgPSBbXSwgcmVxdWlyZWQgPSBbXSwgcmVhZHkgPSB0cnVlO1xuICAgIGlmKEFycmF5LmlzQXJyYXkoZmFjdG9yeSkpIHtcbiAgICAgICAgaGFuZGxlciA9IGZhY3RvcnkucG9wKCk7XG4gICAgICAgIGRlcHMgPSBmYWN0b3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZXIgPSBmYWN0b3J5O1xuICAgICAgICBkZXBzID0gW107XG4gICAgfVxuXG4gICAgZGVwcy5mb3JFYWNoKGZ1bmN0aW9uKG5lZWRlZCkge1xuICAgICAgICB2YXIgc2VhcmNoaW5nID0gaW5qZWN0KHNlbGYsIG5lZWRlZCk7XG4gICAgICAgIGlmKCFzZWFyY2hpbmcpIHtcbiAgICAgICAgICAgIHJlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXF1aXJlZC5wdXNoKG5lZWRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmplY3Rvci5wdXNoKHNlYXJjaGluZyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKCEoc2VsZi5jb21wb25lbnRzW25hbWVdKSkge1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmVhZHk6IHJlYWR5LFxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBkZXBzLFxuICAgICAgICAgICAgaW5qZWN0OiBpbmplY3RvcixcbiAgICAgICAgICAgIHJlcXVpcmVkOiByZXF1aXJlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGludGVybmFsID0gYXBwZmFjdG9yeS5jb21wb25lbnQoaW50ZXJuYWwpO1xuICAgICAgICBzZWxmLmNvbXBvbmVudHNbbmFtZV0gPSBpbnRlcm5hbDtcbiAgICAgICAgaW50ZXJuYWwuZmFjdG9yeSA9IGhhbmRsZXIuYXBwbHkoaW50ZXJuYWwsIGludGVybmFsLmluamVjdCk7XG4gICAgfVxuICAgIGRlYnVnLmVuZCgpO1xufTtcblxuUm9vbUFwcGxpY2F0aW9uLnByb3RvdHlwZS5pbml0Q29tcG9uZW50ID0gZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgZGVidWcuc3RhcnQoJ2luaXRDb21wb25lbnQ6JyArIGNvbXBvbmVudC5uYW1lKTtcbiAgICBpZighY29tcG9uZW50LnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgY29tcG9uZW50LnJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICBlbGVtZW50LnJlZ2lzdGVyKHRoaXMsIGNvbXBvbmVudC5uYW1lLCBjb21wb25lbnQuZmFjdG9yeS5zaGFkb3cpO1xuICAgICAgICAoY29tcG9uZW50LmZhY3RvcnkuaW5pdCB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3Igb24gcmVnaXN0cmF0aW9uIHByb2Nlc3NcbiAgICAgICAgICAgIGRlYnVnLmluZm8oJ1JlZ2lzdGVyaW5nICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICB9KS5hcHBseShjb21wb25lbnQsIGNvbXBvbmVudC5pbmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnLmluZm8oJ0NvbXBvbmVudCAnICsgY29tcG9uZW50Lm5hbWUgKyAnIGFscmVhZHkgcmVnaXN0ZXJlZCcpO1xuICAgIH1cbiAgICBkZWJ1Zy5lbmRcbn1cblxuUm9vbUFwcGxpY2F0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oaG9vaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmb3IodmFyIGluZGV4IGluIHNlbGYuY29tcG9uZW50cykge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gc2VsZi5jb21wb25lbnRzW2luZGV4XTtcbiAgICAgICAgaWYoIWNvbXBvbmVudC5yZWFkeSAmJiBjb21wb25lbnQucmVxdWlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29tcG9uZW50LnJlcXVpcmVkLmZvckVhY2goZnVuY3Rpb24oc3ViaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmluaXRDb21wb25lbnQoc2VsZi5jb21wb25lbnRzW3N1YmluZGV4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmluaXRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICB9XG4gICAgY29tcGlsZXIuYXBwbGljYXRpb24oc2VsZi5uYW1lKTtcbiAgICAoaG9vayB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVidWcuaW5mbygnQXBwbGljYXRpb24gcmVhZHknKTtcbiAgICB9KS5hcHBseShzZWxmKTtcbn07XG5cblJvb21BcHBsaWNhdGlvbi5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzW3V0aWwuY2FtZWxpemUobmFtZSldO1xufTtcblxuZXhwb3J0cy5BcHBsaWNhdGlvbiA9IFJvb21BcHBsaWNhdGlvbjtcblxuZXhwb3J0cy5hcHAgPSBmdW5jdGlvbihuYW1lLCBkZXBzLCBvcHRzKSB7XG4gICAgdmFyIGluc3QgPSBuZXcgUm9vbUFwcGxpY2F0aW9uKG5hbWUsIGRlcHMsIG9wdHMpO1xuICAgIHJldHVybiBpbnN0O1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciBlbmdpbmUgPSByZXF1aXJlKCdtdXN0YWNoZScpO1xudmFyIGRlYnVnID0gdXRpbC5kZWJ1ZygnUm9vbS5jb21waWxlcicsIDApO1xuXG5leHBvcnRzLmFwcGxpY2F0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBhdHRyID0gY29uZmlnLnByZWZpeCArICctJyArIGNvbmZpZy5hdHRyLmFwcDtcbiAgICB2YXIgYXBwbm9kZSA9IHV0aWwuJCgnWycgKyBhdHRyICsgJz1cIicgKyB1dGlsLmh5cGhlbmF0ZShuYW1lKSArICdcIl0nKTtcbiAgICBpZihhcHBub2RlID09PSB1bmRlZmluZWQgfHwgIWFwcG5vZGUpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB1dGlsLiQuYXR0cihib2R5LCAnLScgKyBjb25maWcuYXR0ci5hcHAsIHV0aWwuaHlwaGVuYXRlKG5hbWUpKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLnJlbmRlciA9IGZ1bmN0aW9uKHRhcmdldCwgZGF0YSkge1xuICAgIGlmKCFkYXRhIHx8ICF0YXJnZXQpIHtcbiAgICAgICAgZGVidWcuZXJyb3IoJ05vIGRhdGEgb3Igbm9kZSBnaXZlbiBmb3IgcmVuZGVyaW5nJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGFyZ2V0LmlubmVySFRNTCA9IGVuZ2luZS5yZW5kZXIodGFyZ2V0LmlubmVySFRNTCwgZGF0YSk7XG59O1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlYnVnOiB0cnVlLFxuICAgIHNoYWRvdzogdHJ1ZSxcbiAgICBwcmVmaXg6ICdybScsXG4gICAgYXR0cjoge1xuICAgICAgICBjb21wb25lbnQ6ICdjb21wb25lbnQnLFxuICAgICAgICBhcHA6ICdhcHAnXG4gICAgfVxufTtcbiIsInZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vdXRpbCcpLmRlYnVnKCdEZXBlbmRlbmN5JywgMCk7XG5cbmV4cG9ydHMuaW5qZWN0ID0gZnVuY3Rpb24oYXBwLCBuYW1lKSB7XG4gICAgZGVidWcuc3RhcnQoJ2luamVjdDonICsgbmFtZSk7XG4gICAgdmFyIHJlc3VsdCA9IGFwcC5jb21wb25lbnRzW25hbWVdO1xuICAgIGlmKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhcHAuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24oZGVwZW5kZW5jeSkge1xuICAgICAgICBkZWJ1Zy5pbmZvKCdMb29raW5nIGZvciBnbG9iYWwgZGVwZW5kZW5jeSAnICsgZGVwZW5kZW5jeSk7XG4gICAgICAgIGlmKGRlcGVuZGVuY3kgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGRlYnVnLmluZm8oJ0dsb2JhbCBkZXBlbmRlbmN5IGZvdW5kIScpO1xuICAgICAgICAgICAgcmVzdWx0ID0gd2luZG93W2RlcGVuZGVuY3ldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgICBkZWJ1Zy5lbmQoKTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGRlYnVnID0gdXRpbC5kZWJ1ZygnRWxlbWVudCcsIC0xKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgcmVnaXN0ZXJlZEJ5RGVmYXVsdCA9IFtcbiAgICAnaGVhZGVyJyxcbiAgICAnZGl2JyxcbiAgICAnZm9vdGVyJyxcbiAgICAnbWFpbicsXG4gICAgJ3AnLFxuICAgICdzcGFuJyxcbiAgICAnbmF2JyxcbiAgICAndWwnLFxuICAgICdkbCcsXG4gICAgJ2EnLFxuICAgICdpJ1xuXTtcblxudmFyIGlzUmVnaXN0ZXJlZEVsZW1lbnQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpLmNvbnN0cnVjdG9yICE9PSBIVE1MRWxlbWVudDtcbn07XG5cbmV4cG9ydHMuaXNSZWdpc3RlcmVkID0gaXNSZWdpc3RlcmVkRWxlbWVudDtcblxuZXhwb3J0cy5yZWdpc3RlciA9IGZ1bmN0aW9uKGFwcCwgaWRlbnRpZmllciwgaG9vaykge1xuICAgIGRlYnVnLnN0YXJ0KCdyZWdpc3RlcicpO1xuICAgIGlmKGlzUmVnaXN0ZXJlZEVsZW1lbnQoaWRlbnRpZmllcikgfHwgcmVnaXN0ZXJlZEJ5RGVmYXVsdC5pbmRleE9mKGlkZW50aWZpZXIpID4gLTEpIHtcbiAgICAgICAgZGVidWcuaW5mbygnRWxlbWVudCAnICsgaWRlbnRpZmllciArICcgYWxyZWFkeSByZWdpc3RlcmVkIGluIHRoZSBET00nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuY3JlYXRlKEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgcHJvdG8uY3JlYXRlZENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaGFkb3cgPSB0aGlzLmNyZWF0ZVNoYWRvd1Jvb3QoKTtcbiAgICAgICAgKGhvb2sgfHzCoGZ1bmN0aW9uKCkge30pLmFwcGx5KHNoYWRvdyk7XG4gICAgfTtcbiAgICB2YXIgYW5jaGVzdG9yID0gYXBwLmVsZW1lbnRzW3V0aWwuY2FtZWxpemUoaWRlbnRpZmllcildO1xuICAgIGlmKGFuY2hlc3RvciA9PT0gdW5kZWZpbmVkIHx8ICFhbmNoZXN0b3IpIHtcbiAgICAgICAgYW5jaGVzdG9yID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KHV0aWwuaHlwaGVuYXRlKGlkZW50aWZpZXIpLCB7XG4gICAgICAgICAgICBwcm90b3R5cGU6IHByb3RvXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWJ1Zy5lbmQoKTtcbn07XG4iLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciAkJCA9IHJlcXVpcmUoJy4vdXRpbC9xdWVyeScpLiQ7XG52YXIgY29tcGlsZXIgPSByZXF1aXJlKCcuL2NvbXBpbGVyJyk7XG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi91dGlsL2NvcmUnKS5oeXBoZW5hdGU7XG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL3V0aWwvY29yZScpLmNhbWVsaXplO1xudmFyIGxpc3RlbiA9IHtcbiAgICBvbjogcmVxdWlyZSgnLi91dGlsL2RvbScpLm9uLFxuICAgIG9mZjogcmVxdWlyZSgnLi91dGlsL2RvbScpLm9mZlxufTtcblxuZXhwb3J0cy5jb21wb25lbnQgPSBmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgZmFjdG9yeS5maXJlID0gZnVuY3Rpb24gZmlyZShldmVudCwgZGF0YSwgaG9vaykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gJ29uJyArIGV2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gICAgICAgIChob29rIHx8IGZ1bmN0aW9uKCkge30pKHNlbGYuZmFjdG9yeVt0YXJnZXRdLmFwcGx5KHNlbGYsIGRhdGEpKTtcbiAgICB9O1xuXG4gICAgZmFjdG9yeS5nZXQgPSBmdW5jdGlvbiBnZXROb2RlcygpIHtcbiAgICAgICAgdmFyIGFsbCA9IFtdLCBmaW5hbCA9IFtdLCB0YXJnZXQgPSBoeXBoZW5hdGUoZmFjdG9yeS5uYW1lKTtcbiAgICAgICAgW1xuICAgICAgICAgICAgJCQoJy4nICsgdGFyZ2V0KSxcbiAgICAgICAgICAgICQkKCdbJyArIGNvbmZpZy5wcmVmaXggKyAnLScgKyBjb25maWcuYXR0ci5jb21wb25lbnQgKyAnPVwiJyArIHRhcmdldCArICdcIl0nKSxcbiAgICAgICAgICAgICQkKCdAJyArIHRhcmdldClcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZSkge1xuICAgICAgICAgICAgICAgIGFsbC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWxsLmZvckVhY2goZnVuY3Rpb24oc2V0KSB7XG4gICAgICAgICAgICBpZihzZXQgJiYgdHlwZW9mIHNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChzZXQpLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgIH07XG5cbiAgICBmYWN0b3J5LmJpbmQgPSBmdW5jdGlvbiBiaW5kRXZlbnQoZXZlbnQsIGhvb2spIHtcbiAgICAgICAgZmFjdG9yeS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbmRpbmcpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBmaW5kaW5nICE9PSB1bmRlZmluZWQgJiYgZmluZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpc3Rlbi5vbihmaW5kaW5nLCBldmVudCwgaG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmYWN0b3J5LnJlbmRlckRhdGEgPSBmdW5jdGlvbiByZW5kZXJEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy52aWV3YmFnID0gZGF0YTtcbiAgICAgICAgZmFjdG9yeS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGNvbXBpbGVyLnJlbmRlcihub2RlLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZhY3RvcnkudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kRXZlbnQoZXZlbnQsIGhvb2spIHtcbiAgICAgICAgZmFjdG9yeS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbmRpbmcpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBmaW5kaW5nICE9PSB1bmRlZmluZWQgJiYgZmluZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpc3Rlbi5vZmYoZmluZGluZywgZXZlbnQsIGhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmFjdG9yeS5ub2RlcyA9IGZhY3RvcnkuZ2V0KCk7XG5cbiAgICByZXR1cm4gZmFjdG9yeTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGRlYnVnID0gdXRpbC5kZWJ1ZygnUm9vbScsIDApLl9lbnYoJ25vZGUnKTtcblxuaWYodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcykge1xuICAgIGRlYnVnLmVycm9yKCdSb29tIG11c3QgcnVuIGluIGEgYnJvd3NlciBhbmQgbm90IE5vZGUuanMnKTtcbn1cblxudmFyIHJvb20gPSByb29tIHx8IHt9O1xucm9vbS5hcHAgPSByZXF1aXJlKCcuL2FwcCcpLmFwcDtcbnJvb20uJCA9IHJlcXVpcmUoJy4vdXRpbC9xdWVyeScpLiQ7XG51dGlsLm1peGluKHJvb20uJCwgcmVxdWlyZSgnLi91dGlsL2FqYXgnKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByb29tO1xuIiwidmFyIGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpKCdSb29tLmFqYXgnKTtcbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHI7XG5cbiAgICBpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2ZXJzaW9ucyA9IFtcbiAgICAgICAgICAgIFwiTVNYTUwyLlhtbEh0dHAuNS4wXCIsXG4gICAgICAgICAgICBcIk1TWE1MMi5YbWxIdHRwLjQuMFwiLFxuICAgICAgICAgICAgXCJNU1hNTDIuWG1sSHR0cC4zLjBcIixcbiAgICAgICAgICAgIFwiTVNYTUwyLlhtbEh0dHAuMi4wXCIsXG4gICAgICAgICAgICBcIk1pY3Jvc29mdC5YbWxIdHRwXCJcbiAgICAgICAgXTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSB2ZXJzaW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB4aHIgPSBuZXcgQWN0aXZlWE9iamVjdCh2ZXJzaW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgZGVidWcuZXJyb3IoZXgubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHhoci5yZWFkeVN0YXRlIDwgNCB8fMKgeGhyLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICBkZWJ1Zy53YXJuKCdYTUxIdHRwUmVxdWVzdCBub3QgcmVhZHkgeWV0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZih4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgY2FsbGJhY2soeGhyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIuc2VuZCgnJyk7XG59XG4iLCIvKipcbiogQ2hlY2tzIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICckJyBvciB1bmRlcnNjb3JlICdfJ1xuKiBAcGFyYW0ge1N0cmluZ30gdmFsICAgICAgSW5wdXRcbiogQHJldHVybiB7Qm9vbGVhbn1cbiovXG5leHBvcnRzLmlzUmVzZXJ2ZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGMgPSAodmFsICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1Rjtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBzdHJpbmcgdG8gdXBwZXJjYXNlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9VcHBlciAoXywgYykge1xuICAgIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7XG59XG5cbi8qKlxuKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxtaXRlZCBzdHJpbmcuXG4qIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICBIeXBoZWQgSW5wdXRcbiogQHJldHVybiB7U3RyaW5nfVxuKi9cbmV4cG9ydHMuY2FtZWxpemUgPSBmdW5jdGlvbiAoaHlwaGVkKSB7XG4gICAgcmV0dXJuIGh5cGhlZC5yZXBsYWNlKC8tKFxcdykvZywgdG9VcHBlcik7XG59XG5cbi8qKlxuKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuKiBAcGFyYW0ge1N0cmluZ30gY2FtZWwgICAgQ2FtZWxjYXNlIElucHV0XG4qIEByZXR1cm4ge1N0cmluZ31cbiovXG5leHBvcnRzLmh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChjYW1lbCkge1xuICAgIHJldHVybiBjYW1lbFxuICAgIC5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiogU2ltcGxlIGJpbmRpbmdzIGV2ZW4gZmFzdGVyIHRoYW4gbmF0aXZlIGltcGxlbWVudGF0aW9uXG4qIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4qIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiogQHJldHVybiB7RnVuY3Rpb259XG4qL1xuZXhwb3J0cy5iaW5kID0gZnVuY3Rpb24gKGhhbmRsZSwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgcmV0dXJuIHNpemUgPyBzaXplID4gMVxuICAgICAgICAgICAgPyBoYW5kbGUuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgOiBoYW5kbGUuY2FsbChjb250ZXh0LCBhKVxuICAgICAgICA6IGhhbmRsZS5jYWxsKGNvbnRleHQpO1xuICAgIH07XG59XG5cbi8qKlxuKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4qIEBwYXJhbSB7T2JqZWN0fSB0b1xuKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuKi9cbmV4cG9ydHMubWl4aW4gPSBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldXG4gICAgfVxuICAgIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIG5lZWRsZSBleGlzdHMgaW4gYW4gYXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSBhcnJcbiAqIEBwYXJhbSAge1N0cmluZ30gbmVlZGxlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmNvbnRhaW5zID0gZnVuY3Rpb24oYXJyLCBuZWVkbGUpIHtcbiAgICBmb3IodmFyIGkgaW4gYXJyKSB7XG4gICAgICAgIGlmKGFycltpXSA9PT0gbmVlZGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4iLCJ2YXIgY2hhbGsgPSByZXF1aXJlKCdjaGFsaycpO1xuXG4vKipcbiAqIEVhc3kgZGVidWdnaW5nIHdyYXBwZWQtdXAgaW4gYSBjbGFzcyxcbiAqIHNldCBsb2dsZXZlbCB3aXRoIHRoZSBzZWNvbmQgcGFyYW1ldGVyO1xuICpcbiAqICAgLTEgIFNpbGVudCBtb2RlIChoaWRlIGV2ZXJ5dGhpbmcpXG4gKiAgICAwICBEaXNwbGF5IG9ubHkgZXJyb3JzXG4gKiAgICAxICBEaXNwbGF5IHdhcm5pbmdzIGFuZCBlcnJvcnNcbiAqICAgIDIgIERpc3BsYXkgd2FybmluZ3MsIGVycm9ycyBhbmQgaW5mb3NcbiAqICAgIDMgIERpc3BsYXkgZXZlcnl0aGluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7SW50ZWdlcn0gbGV2ZWxcbiAqL1xuZnVuY3Rpb24gUm9vbURlYnVnZ2VyKG5hbWVzcGFjZSwgbGV2ZWwpIHtcbiAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZSB8fCAnPHVua25vd24+JztcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbCB8fCAwO1xuICAgIHRoaXMuZW52ID0gJ2Jyb3dzZXInO1xuICAgIHRoaXMud3JpdGVycyA9IHtcbiAgICAgICAgYnJvd3Nlcjoge1xuICAgICAgICAgICAgbG9nOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICBpZihsZXZlbCA8PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYobGV2ZWwgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3Ioc3RyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3YXJuOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICBpZihsZXZlbCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHN0cik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5mbzogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYobGV2ZWwgPD0gMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhzdHIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIGlmKGxldmVsIDw9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLnN1Y2NlcyhzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0cik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoYWxrLnJlZChzdHIpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3YXJuOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjaGFsay55ZWxsb3coc3RyKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5mbzogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coY2hhbGsuY3lhbihzdHIpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjaGFsay5ncmVlbihzdHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuUm9vbURlYnVnZ2VyLnByb3RvdHlwZS5fZW52ID0gZnVuY3Rpb24oZW52aXJvbmVtZW50KSB7XG4gICAgdGhpcy5lbnYgPSBlbnZpcm9uZW1lbnQ7XG59O1xuXG5Sb29tRGVidWdnZXIucHJvdG90eXBlLl9vdXQgPSBmdW5jdGlvbihtb2RlLCBtZXNzYWdlKSB7XG4gICAgaWYodGhpcy5lbmFibGVkICYmIHRoaXMubGV2ZWwgPiAtMSkge1xuICAgICAgICB2YXIgc3Rkb3V0ID0gdGhpcy53cml0ZXJzW3RoaXMuZW52XVttb2RlXTtcbiAgICAgICAgaWYodHlwZW9mIHN0ZG91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3Rkb3V0KCdbJyArIHRoaXMubmFtZXNwYWNlICsgJ10gJyArIG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGRvdXQuYXBwbHkoY29uc29sZSwgJ1snICsgdGhpcy5uYW1lc3BhY2UgKyAnXSAnICsgbWVzc2FnZSk7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblJvb21EZWJ1Z2dlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihzdWJzcGFjZSkge1xuICAgIGlmKGNvbnNvbGUuZ3JvdXApIHtcbiAgICAgICAgaWYodGhpcy5sZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAodGhpcy5uYW1lc3BhY2UgKyAoc3Vic3BhY2UgPyAnLicgKyBzdWJzcGFjZSA6ICcnKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Sb29tRGVidWdnZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKGNvbnNvbGUuZ3JvdXBFbmQpIHtcbiAgICAgICAgaWYodGhpcy5sZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblJvb21EZWJ1Z2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHRoaXMuX291dCgnbG9nJywgbWVzc2FnZSk7XG59O1xuXG5Sb29tRGVidWdnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5fb3V0KCd3YXJuJywgbWVzc2FnZSk7XG59O1xuXG5Sb29tRGVidWdnZXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5fb3V0KCdpbmZvJywgbWVzc2FnZSk7XG59O1xuXG5Sb29tRGVidWdnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHRoaXMuX291dCgnZXJyb3InLCBtZXNzYWdlKTtcbn07XG5cblJvb21EZWJ1Z2dlci5wcm90b3R5cGUuc3VjY2VzcyA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9vdXQoJ3N1Y2Nlc3MnLCBtZXNzYWdlKTtcbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWVzcGFjZSwgbGV2ZWwpIHtcbiAgICByZXR1cm4gbmV3IFJvb21EZWJ1Z2dlcihuYW1lc3BhY2UsIGxldmVsKTtcbn07XG4iLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi8uLi9jb25maWcnKTtcblxuLyoqXG4gKiBHZXR0aW5nIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgb24gYSBub2RlXG4gKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGtleVxuICogQHBhcmFtICB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4gez9TdHJpbmd9XG4gKi9cbmV4cG9ydHMuYXR0ciA9IGZ1bmN0aW9uKG5vZGUsIGtleSwgdmFsKSB7XG4gICAga2V5ID0gY29uZmlnLnByZWZpeCArIGtleTtcbiAgICBpZighdmFsICYmIG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIGlmKG5vZGUgJiYga2V5ICYmIHZhbCkge1xuICAgICAgICByZXR1cm4gbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW5zZXJ0IG5vZGUgYmVmb3JlIHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICovXG5leHBvcnRzLmJlZm9yZSA9IGZ1bmN0aW9uKG5vZGUsIHRhcmdldCkge1xuICAgIHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIEluc2VydCBub2RlIGFmdGVyIHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICovXG5leHBvcnRzLmFmdGVyID0gZnVuY3Rpb24obm9kZSwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgICAgICBleHBvcnRzLmJlZm9yZShub2RlLCB0YXJnZXQubmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgbm9kZSBmcm9tIERPTVxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKi9cbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBQcmVwZW5kIG5vZGUgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICovXG5cbmV4cG9ydHMucHJlcGVuZCA9IGZ1bmN0aW9uKG5vZGUsIHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuZmlyc3RDaGlsZCkge1xuICAgICAgICBleHBvcnRzLmJlZm9yZShub2RlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXBsYWNlIHRhcmdldCB3aXRoIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuZXhwb3J0cy5yZXBsYWNlID0gZnVuY3Rpb24odGFyZ2V0LCBub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChub2RlLCB0YXJnZXQpO1xuICAgIH1cbn1cblxuZXhwb3J0cy5vbiA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYobm9kZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5hdHRhY2hFdmVudCkgIHtcbiAgICAgICAgbm9kZS5hdHRhY2hFdmVudChldmVudCwgaGFuZGxlcik7XG4gICAgfVxufVxuXG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZXhwb3J0cy5vZmYgPSBmdW5jdGlvbiAobm9kZSwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZihub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9ICBlbHNlIGlmIChub2RlLmRldGFjaEV2ZW50KSAge1xuICAgICAgICBub2RlLmRldGFjaEV2ZW50KGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG59XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtTdHJvbmd9IGNsc1xuICovXG5leHBvcnRzLmFkZENsYXNzID0gZnVuY3Rpb24gKG5vZGUsIGNscykge1xuICAgIGlmIChub2RlLmNsYXNzTGlzdCkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3VyID0gJyAnICsgKG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArICcgJztcbiAgICAgICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3Ryb25nfSBjbHNcbiAqL1xuZXhwb3J0cy5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChub2RlLCBjbHMpIHtcbiAgICBpZiAobm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGN1ciA9ICcgJyArIChub2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICc7XG4gICAgICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKTtcbiAgICB9XG59XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuY29yZS5taXhpbihleHBvcnRzLCBjb3JlKTtcbmNvcmUubWl4aW4oZXhwb3J0cywgcmVxdWlyZSgnLi9xdWVyeScpKTtcbmNvcmUubWl4aW4oZXhwb3J0cy4kLCByZXF1aXJlKCcuL2RvbScpKTtcbmV4cG9ydHMuZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmFqYXggPSByZXF1aXJlKCcuL2FqYXgnKTtcbiIsIi8qKlxuICogQ3VzdG9tIGFuZCBtaW5pLWltcGxlbWVudGF0aW9uIG9mIGpRdWVyeSBzZWxlY3RvcnNcbiAqIHdoaWNoIGhlbHBzIHRvIHNlbGVjdCBub2RlcyBpbiB0aGUgYnJvd3NlclxuICogQHBhcmFtICB7c3RyaW5nfSBzZWxlY3RvciAgICBDU1MyLzMgU2VsZWN0b3JcbiAqIEByZXR1cm4ge05vZGV9ICAgICAgICAgICAgICAgMCwgMSBvciBtdWx0aXBsZSBOb2Rlc1xuICovXG52YXIgcXVlcnkgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBtYXRjaGVzID0ge1xuICAgICAgICAnIyc6ICdnZXRFbGVtZW50QnlJZCcsIC8vICQoJyNteUlkJylcbiAgICAgICAgJy4nOiAnZ2V0RWxlbWVudHNCeUNsYXNzTmFtZScsIC8vICQoJy5teUNsYXNzJylcbiAgICAgICAgJ0AnOiAnZ2V0RWxlbWVudHNCeU5hbWUnLCAvLyAkKCdAbXlOYW1lJylcbiAgICAgICAgJz0nOiAnZ2V0RWxlbWVudHNCeVRhZ05hbWUnLCAvLyAkKCc9Ym9keScpXG4gICAgICAgICc/JzogJ3F1ZXJ5U2VsZWN0b3JBbGwnIC8vICQoJz9hbnl0aGluZycpXG4gICAgfSwgIHJleCA9IC9bPSNALipdLy5leGVjKHNlbGVjdG9yKVswXTtcbiAgICB2YXIgbm9kZXMgPSBkb2N1bWVudFttYXRjaGVzW3JleF1dKHNlbGVjdG9yLnNwbGl0KHJleClbMV0pO1xuICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAxID8gbm9kZXMgOiBub2Rlc1swXTtcbn07XG5cbmV4cG9ydHMuJCA9IHF1ZXJ5O1xuIl19
